# 在现有代码的基础上，修改以下部分：

def extract_nodes_edges_from_result(result):
    """直接从Nebula Result中提取节点和边信息"""
    nodes = []
    edges = []
    
    if not result or not result.is_succeeded():
        return nodes, edges
    
    for record in result:
        for value_wrapper in record.values():
            # 处理节点
            if hasattr(value_wrapper, "is_node") and value_wrapper.is_node():
                try:
                    node = value_wrapper.as_node()
                    node_id = str(node.get_id())
                    
                    # 获取标签
                    tags = []
                    if hasattr(node, "tags") and node.tags():
                        tags = node.tags()
                    elif hasattr(node, "get_tags"):
                        tags = node.get_tags()
                    
                    # 获取属性
                    properties = {}
                    try:
                        if hasattr(node, "properties"):
                            props = node.properties()
                            if props:
                                for tag in tags:
                                    prop_dict = props.get(tag, {})
                                    if prop_dict:
                                        properties.update(prop_dict)
                    except Exception:
                        pass
                    
                    nodes.append({
                        'id': node_id,
                        'label': ', '.join(tags) if tags else 'Vertex',
                        'properties': properties
                    })
                except Exception as e:
                    continue
            
            # 处理边
            elif hasattr(value_wrapper, "is_edge") and value_wrapper.is_edge():
                try:
                    edge = value_wrapper.as_edge()
                    
                    # 获取源节点和目标节点
                    src_id = str(edge.start_vertex_id()) if hasattr(edge, 'start_vertex_id') else str(edge.get_src_id())
                    dst_id = str(edge.end_vertex_id()) if hasattr(edge, 'end_vertex_id') else str(edge.get_dst_id())
                    
                    # 获取边类型
                    edge_name = str(edge.edge_name()) if hasattr(edge, 'edge_name') else 'edge'
                    
                    # 获取属性
                    properties = {}
                    try:
                        if hasattr(edge, "properties"):
                            props = edge.properties()
                            if props:
                                properties.update(props)
                    except Exception:
                        pass
                    
                    # 获取rank（如果存在）
                    rank = None
                    if hasattr(edge, "ranking"):
                        rank = edge.ranking()
                    
                    edges.append({
                        'source': src_id,
                        'target': dst_id,
                        'type': edge_name,
                        'label': edge_name,
                        'properties': properties,
                        'rank': rank
                    })
                except Exception as e:
                    continue
            
            # 处理路径
            elif hasattr(value_wrapper, "is_path") and value_wrapper.is_path():
                try:
                    path = value_wrapper.as_path()
                    
                    # 提取路径中的节点
                    if hasattr(path, "nodes"):
                        path_nodes = path.nodes()
                        for node in path_nodes:
                            node_id = str(node.get_id())
                            nodes.append({
                                'id': node_id,
                                'label': 'Vertex',
                                'properties': {}
                            })
                    
                    # 提取路径中的边
                    if hasattr(path, "relationships"):
                        rels = path.relationships()
                        for rel in rels:
                            src_id = str(rel.start_vertex_id()) if hasattr(rel, 'start_vertex_id') else 'unknown'
                            dst_id = str(rel.end_vertex_id()) if hasattr(rel, 'end_vertex_id') else 'unknown'
                            edge_name = str(rel.edge_name()) if hasattr(rel, 'edge_name') else 'edge'
                            
                            edges.append({
                                'source': src_id,
                                'target': dst_id,
                                'type': edge_name,
                                'label': edge_name,
                                'properties': {},
                                'rank': rel.ranking() if hasattr(rel, 'ranking') else None
                            })
                except Exception as e:
                    continue
    
    # 去重节点
    unique_nodes = {}
    for node in nodes:
        node_id = node['id']
        if node_id not in unique_nodes:
            unique_nodes[node_id] = node
        else:
            # 合并标签
            if node['label'] != 'Vertex' and node['label'] not in unique_nodes[node_id]['label']:
                unique_nodes[node_id]['label'] += f", {node['label']}"
            # 合并属性
            unique_nodes[node_id]['properties'].update(node['properties'])
    
    return list(unique_nodes.values()), edges


def visualize_graph_from_result(result):
    """直接从Nebula结果创建可视化"""
    nodes, edges = extract_nodes_edges_from_result(result)
    
    if not nodes and not edges:
        return None
    
    # 创建图形
    G = nx.DiGraph()
    
    # 添加节点
    for node in nodes:
        node_id = node['id']
        label = node['label']
        props = node['properties']
        
        # 创建节点标签
        tooltip = f"ID: {node_id}<br>Type: {label}"
        if props:
            prop_str = "<br>".join([f"{k}: {v}" for k, v in props.items()])
            tooltip += f"<br>{prop_str}"
        
        G.add_node(node_id, label=label, tooltip=tooltip, properties=props)
    
    # 添加边
    for edge in edges:
        source = edge['source']
        target = edge['target']
        edge_type = edge['type']
        
        # 创建边标签
        tooltip = f"{source} → {target}<br>Type: {edge_type}"
        if edge.get('properties'):
            prop_str = "<br>".join([f"{k}: {v}" for k, v in edge['properties'].items()])
            tooltip += f"<br>{prop_str}"
        if edge.get('rank'):
            tooltip += f"<br>Rank: {edge['rank']}"
        
        G.add_edge(source, target, label=edge_type, tooltip=tooltip, type=edge_type)
    
    # 使用更好的布局算法
    if len(nodes) > 0:
        try:
            # 尝试不同的布局算法
            if len(nodes) < 50:
                pos = nx.spring_layout(G, seed=42, k=1.5, iterations=50)
            elif len(nodes) < 200:
                pos = nx.kamada_kawai_layout(G)
            else:
                pos = nx.circular_layout(G)
        except:
            pos = nx.spring_layout(G, seed=42)
        
        # 创建边轨迹
        edge_x, edge_y = [], []
        edge_text = []
        
        for edge in G.edges(data=True):
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_x += [x0, x1, None]
            edge_y += [y0, y1, None]
            edge_text.append(edge[2].get('tooltip', ''))
        
        edge_trace = go.Scatter(
            x=edge_x,
            y=edge_y,
            line=dict(width=1.5, color='#888'),
            hoverinfo='text',
            text=edge_text,
            mode='lines',
            name='Edges'
        )
        
        # 创建节点轨迹
        node_x, node_y, node_text, node_labels, node_colors = [], [], [], [], []
        
        for node in G.nodes(data=True):
            x, y = pos[node[0]]
            node_x.append(x)
            node_y.append(y)
            node_text.append(node[1].get('tooltip', str(node[0])))
            node_labels.append(node[1].get('label', str(node[0])))
            
            # 根据节点类型分配颜色
            node_type = node[1].get('label', '').lower()
            if 'player' in node_type:
                node_colors.append('#FF6B6B')  # 红色
            elif 'team' in node_type:
                node_colors.append('#4ECDC4')  # 青色
            elif 'account' in node_type:
                node_colors.append('#45B7D1')  # 蓝色
            else:
                node_colors.append('#96CEB4')  # 绿色
        
        node_trace = go.Scatter(
            x=node_x,
            y=node_y,
            mode='markers+text',
            hoverinfo='text',
            text=node_labels,
            hovertext=node_text,
            textposition='bottom center',
            marker=dict(
                size=20,
                color=node_colors,
                line=dict(width=2, color='white')
            ),
            name='Nodes'
        )
        
        # 创建图形
        fig = go.Figure(
            data=[edge_trace, node_trace],
            layout=go.Layout(
                title='Nebula Graph Visualization',
                title_x=0.5,
                showlegend=True,
                hovermode='closest',
                margin=dict(b=20, l=20, r=20, t=40),
                xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                plot_bgcolor='white',
                legend=dict(
                    orientation="h",
                    yanchor="bottom",
                    y=1.02,
                    xanchor="right",
                    x=1
                )
            )
        )
        
        return fig
    
    return None


# 修改execute_query函数，保存原始result
def execute_query(query):
    """Execute query statement"""
    if not st.session_state.session:
        st.error("Please connect to Nebula Graph first")
        return None
    
    query = query.strip()
    if not query:
        st.error("Query cannot be empty")
        return None
    
    requires_space = check_query_requires_space(query)
    
    if requires_space and not st.session_state.current_space:
        st.error("This query requires a graph space to be selected. Please select a space first.")
        return None
    
    try:
        start_time = time.time()
        result = st.session_state.session.execute(query)
        execution_time = time.time() - start_time
        
        # 保存原始结果用于可视化
        st.session_state.last_raw_result = result
        
        # 记录查询历史
        query_record = {
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'query': query,
            'success': result.is_succeeded(),
            'time': f"{execution_time:.3f}s",
            'space': st.session_state.current_space
        }
        st.session_state.query_history.append(query_record)
        
        # 处理USE语句
        if query.strip().upper().startswith("USE "):
            if result.is_succeeded():
                parts = query.split()
                if len(parts) >= 2:
                    space_name = parts[1].replace(';', '')
                    st.session_state.current_space = space_name
                    st.success(f"Switched to space: {space_name}")
                    fetch_available_spaces()
        
        # 处理CREATE/DROP SPACE
        elif query.strip().upper().startswith(("CREATE SPACE", "DROP SPACE")):
            if result.is_succeeded():
                time.sleep(1)
                fetch_available_spaces()
        
        return result
        
    except Exception as e:
        st.error(f"Query execution error: {str(e)}")
        return None


# 修改tab2中的可视化部分
with tab2:
    st.header("Data Visualization")
    
    # 添加查询类型提示
    st.info("""
    **For best graph visualization results, use MATCH queries that return paths or relationships:**
    - `MATCH p=(v1)-[e]->(v2) RETURN p LIMIT 20`
    - `MATCH (v1)-[e:follow]->(v2) RETURN v1, e, v2`
    - `MATCH (v) RETURN v LIMIT 20`
    """)
    
    if 'last_raw_result' in st.session_state and st.session_state.last_raw_result is not None:
        result = st.session_state.last_raw_result
        
        if result.is_succeeded():
            viz_type = st.radio(
                "Select Visualization Type",
                ["Graph View", "Table View", "Statistics"],
                horizontal=True,
                key="viz_type_selector"
            )
            
            if viz_type == "Graph View":
                # 直接使用原始结果进行可视化
                fig = visualize_graph_from_result(result)
                
                if fig:
                    st.plotly_chart(fig, use_container_width=True, use_container_width=True)
                    
                    # 显示图统计信息
                    nodes, edges = extract_nodes_edges_from_result(result)
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("Nodes", len(nodes))
                    with col2:
                        st.metric("Edges", len(edges))
                    with col3:
                        st.metric("Graph Density", 
                                 f"{len(edges) / max(len(nodes), 1):.3f}" if nodes else "N/A")
                else:
                    st.warning("No graph structure found in query results. Try a MATCH query that returns paths or relationships.")
                    
                    # 回退到表格视图
                    df = display_result_table(result)
                    if df is not None and not df.empty:
                        st.dataframe(df, use_container_width=True)
            
            elif viz_type == "Table View":
                df = display_result_table(result)
                if df is not None and not df.empty:
                    st.dataframe(df, use_container_width=True)
                    
                    # 添加导出功能
                    csv = df.to_csv(index=False).encode('utf-8')
                    st.download_button(
                        label="Download as CSV",
                        data=csv,
                        file_name=f"nebula_result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv"
                    )
                else:
                    st.info("No data to display")
            
            elif viz_type == "Statistics":
                df = display_result_table(result)
                if df is not None and not df.empty:
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("Data Overview")
                        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
                        st.metric("Total Rows", len(df))
                        st.metric("Total Columns", len(df.columns))
                        st.markdown('</div>', unsafe_allow_html=True)
                        
                        # 数据预览
                        st.subheader("First 5 Rows")
                        st.dataframe(df.head(), use_container_width=True)
                    
                    with col2:
                        st.subheader("Column Details")
                        column_info = []
                        for col in df.columns:
                            non_null = df[col].notnull().sum()
                            unique_count = df[col].nunique()
                            sample_value = str(df[col].iloc[0]) if non_null > 0 else "NULL"
                            column_info.append({
                                'Column': col,
                                'Non-Null': non_null,
                                'Unique Values': unique_count,
                                'Sample': sample_value[:50] + "..." if len(sample_value) > 50 else sample_value
                            })
                        
                        st.dataframe(pd.DataFrame(column_info), use_container_width=True)
        else:
            st.error(f"Query failed: {result.error_msg()}")
    else:
        st.info("Please execute a query in the Query Editor tab first")
