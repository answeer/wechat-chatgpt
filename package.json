import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import networkx as nx
from datetime import datetime
import time

# Nebula Graph imports
try:
    from nebula3.gclient.net import ConnectionPool
    from nebula3.Config import Config
    NEBULA_AVAILABLE = True
except ImportError:
    NEBULA_AVAILABLE = False
    st.warning("Nebula3 Python client not installed. Please run: pip install nebula3-python")

# Page configuration
st.set_page_config(
    page_title="Nebula Graph Query Tool",
    page_icon="üîÆ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #4B8BBE;
        text-align: center;
        margin-bottom: 2rem;
    }
    .query-box {
        background-color: #f0f2f6;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
    }
    .result-box {
        background-color: #ffffff;
        padding: 15px;
        border-radius: 5px;
        border-left: 4px solid #4B8BBE;
        margin-top: 10px;
    }
    .stButton>button {
        background-color: #4B8BBE;
        color: white;
        font-weight: bold;
    }
    .metric-card {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #dee2e6;
    }
</style>
""", unsafe_allow_html=True)

# Application title
st.markdown('<h1 class="main-header">üîÆ Nebula Graph Query & Visualization Tool</h1>', unsafe_allow_html=True)

# Initialize session state
if 'connection_pool' not in st.session_state:
    st.session_state.connection_pool = None
if 'session' not in st.session_state:
    st.session_state.session = None
if 'query_history' not in st.session_state:
    st.session_state.query_history = []
if 'current_space' not in st.session_state:
    st.session_state.current_space = None

def initialize_nebula_connection():
    """Initialize Nebula Graph connection"""
    if not NEBULA_AVAILABLE:
        return False
    
    try:
        config = Config()
        config.max_connection_pool_size = 10
        
        connection_pool = ConnectionPool()
        
        # Connection parameters
        addresses = [(st.session_state.get('nebula_host', '127.0.0.1'), 
                     st.session_state.get('nebula_port', 9669))]
        
        # Initialize connection pool
        if not connection_pool.init(addresses, config):
            st.error("Connection pool initialization failed")
            return False
        
        # Get session
        session = connection_pool.get_session(
            st.session_state.get('nebula_username', 'root'),
            st.session_state.get('nebula_password', 'nebula')
        )
        
        # Test connection
        result = session.execute("SHOW HOSTS")
        if not result.is_succeeded():
            st.error(f"Connection test failed: {result.error_msg()}")
            session.release()
            return False
        
        st.session_state.connection_pool = connection_pool
        st.session_state.session = session
        return True
        
    except Exception as e:
        st.error(f"Connection failed: {str(e)}")
        return False

def execute_query(query):
    """Execute query statement"""
    if not st.session_state.session:
        st.error("Please connect to Nebula Graph first")
        return None
    
    try:
        # Handle USE statement to update current space
        if query.strip().upper().startswith("USE "):
            result = st.session_state.session.execute(query)
            if result.is_succeeded():
                space_name = query.strip().split()[1]
                st.session_state.current_space = space_name
                st.success(f"Switched to space: {space_name}")
        
        # Execute query
        start_time = time.time()
        result = st.session_state.session.execute(query)
        execution_time = time.time() - start_time
        
        # Record query history
        query_record = {
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'query': query,
            'success': result.is_succeeded(),
            'time': f"{execution_time:.3f}s"
        }
        st.session_state.query_history.append(query_record)
        
        return result
        
    except Exception as e:
        st.error(f"Query execution error: {str(e)}")
        return None

def result_to_dataframe(result):
    """Convert Nebula query result to DataFrame"""
    if not result or not result.is_succeeded():
        return None
    
    try:
        # Get column names
        column_names = result.keys()
        
        # Get data
        rows = []
        for record in result:
            row = []
            for value in record.values():
                # Handle different value types
                if value.is_empty():
                    row.append(None)
                elif value.is_null():
                    row.append('NULL')
                elif value.is_bool():
                    row.append(value.get_bool())
                elif value.is_int():
                    row.append(value.get_int())
                elif value.is_double():
                    row.append(value.get_double())
                elif value.is_string():
                    row.append(value.get_string())
                elif value.is_time():
                    row.append(str(value.get_time()))
                elif value.is_date():
                    row.append(str(value.get_date()))
                elif value.is_datetime():
                    row.append(str(value.get_datetime()))
                elif value.is_list():
                    row.append(str(value.get_list()))
                elif value.is_set():
                    row.append(str(value.get_set()))
                elif value.is_map():
                    row.append(str(value.get_map()))
                elif value.is_vertex():
                    row.append(f"Vertex({value.get_vertex().vid.get_sVal()})")
                elif value.is_edge():
                    row.append(f"Edge({value.get_edge().src.get_sVal()}->{value.get_edge().dst.get_sVal()})")
                elif value.is_path():
                    row.append(f"Path({len(value.get_path().nodes)} nodes)")
                else:
                    row.append(str(value))
            rows.append(row)
        
        # Create DataFrame
        df = pd.DataFrame(rows, columns=column_names)
        return df
        
    except Exception as e:
        st.error(f"Result conversion error: {str(e)}")
        return None

def visualize_graph_from_dataframe(df):
    """Create graph visualization from DataFrame"""
    if df is None or df.empty:
        return None
    
    try:
        G = nx.Graph()
        positions = {}
        
        # Try to extract nodes and edges from data
        for idx, row in df.iterrows():
            # Process rows containing vertices and edges
            for col in df.columns:
                value = str(row[col])
                if 'Vertex' in value:
                    # Extract vertex ID
                    vid = value.split('(')[1].split(')')[0]
                    G.add_node(vid, type='vertex')
                    positions[vid] = (idx * 2, idx)
                elif 'Edge' in value:
                    # Extract edge
                    edge_info = value.split('(')[1].split(')')[0]
                    parts = edge_info.split('->')
                    if len(parts) == 2:
                        src, dst = parts[0], parts[1]
                        G.add_edge(src, dst)
        
        # If no edges, create simple relationship graph
        if len(G.edges()) == 0:
            # Treat each row as a node
            for idx, row in df.iterrows():
                node_id = f"Row{idx}"
                G.add_node(node_id, label=str(row.to_dict()))
                positions[node_id] = (idx, idx)
                
                # Add connections
                if idx > 0:
                    G.add_edge(f"Row{idx-1}", node_id)
        
        # Create Plotly figure
        edge_x = []
        edge_y = []
        for edge in G.edges():
            x0, y0 = positions[edge[0]]
            x1, y1 = positions[edge[1]]
            edge_x.extend([x0, x1, None])
            edge_y.extend([y0, y1, None])
        
        edge_trace = go.Scatter(
            x=edge_x, y=edge_y,
            line=dict(width=1, color='#888'),
            hoverinfo='none',
            mode='lines',
            name='Edges'
        )
        
        node_x = []
        node_y = []
        node_text = []
        for node in G.nodes():
            x, y = positions[node]
            node_x.append(x)
            node_y.append(y)
            node_text.append(f"Node: {node}")
        
        node_trace = go.Scatter(
            x=node_x, y=node_y,
            mode='markers+text',
            hoverinfo='text',
            text=[str(n) for n in G.nodes()],
            textposition="bottom center",
            marker=dict(
                showscale=True,
                colorscale='YlGnBu',
                size=20,
                color=[],
                line_width=2
            ),
            name='Nodes'
        )
        
        fig = go.Figure(data=[edge_trace, node_trace],
                       layout=go.Layout(
                           title='Graph Visualization',
                           titlefont_size=16,
                           showlegend=False,
                           hovermode='closest',
                           margin=dict(b=20,l=5,r=5,t=40),
                           xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                           yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
                       ))
        
        return fig
        
    except Exception as e:
        st.error(f"Visualization creation error: {str(e)}")
        return None

# Sidebar - Connection Configuration
with st.sidebar:
    st.header("üîó Connection Configuration")
    
    # Connection parameters
    nebula_host = st.text_input("Nebula Graph Address", value="127.0.0.1", key="nebula_host")
    nebula_port = st.number_input("Port", value=9669, min_value=1, max_value=65535, key="nebula_port")
    nebula_username = st.text_input("Username", value="root", key="nebula_username")
    nebula_password = st.text_input("Password", value="nebula", type="password", key="nebula_password")
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button("Connect to Nebula", use_container_width=True, type="primary"):
            with st.spinner("Connecting..."):
                if initialize_nebula_connection():
                    st.success("Connected successfully!")
    with col2:
        if st.button("Disconnect", use_container_width=True):
            if st.session_state.session:
                st.session_state.session.release()
                st.session_state.connection_pool.close()
                st.session_state.session = None
                st.session_state.connection_pool = None
                st.info("Disconnected")
    
    st.divider()
    
    # Query History
    st.header("üìú Query History")
    if st.session_state.query_history:
        for i, record in enumerate(reversed(st.session_state.query_history[-5:])):
            with st.expander(f"{record['timestamp']} - {record['query'][:50]}..."):
                st.code(record['query'])
                status = "‚úÖ Success" if record['success'] else "‚ùå Failed"
                st.caption(f"Status: {status}")
                st.caption(f"Time: {record['time']}")
    else:
        st.caption("No query history yet")
    
    st.divider()
    
    # Query Examples
    st.header("üí° Query Examples")
    examples = {
        "Show all spaces": "SHOW SPACES",
        "Show all tags": "SHOW TAGS",
        "Show all edge types": "SHOW EDGES",
        "Query vertices example": "MATCH (v) RETURN v LIMIT 10",
        "Query edges example": "MATCH ()-[e]->() RETURN e LIMIT 10",
        "Subgraph query": "MATCH p=(v1)-[e*2]-(v2) RETURN p LIMIT 5"
    }
    
    selected_example = st.selectbox("Select example query", list(examples.keys()))
    if st.button("Use Example", use_container_width=True):
        st.session_state.example_query = examples[selected_example]

# Main Interface
tab1, tab2, tab3 = st.tabs(["üìù Query Editor", "üìä Data Visualization", "üìà System Status"])

with tab1:
    st.markdown('<div class="query-box">', unsafe_allow_html=True)
    
    # Query input
    query_input = st.text_area(
        "Enter Query Statement",
        height=150,
        value=st.session_state.get('example_query', ''),
        placeholder="Enter your nGQL query, e.g.:\nMATCH (v:player) RETURN v.player.name, v.player.age LIMIT 10",
        key="query_input"
    )
    
    col1, col2, col3 = st.columns([1, 1, 2])
    with col1:
        execute_btn = st.button("üöÄ Execute Query", use_container_width=True, type="primary")
    with col2:
        if st.button("üîÑ Clear Results", use_container_width=True):
            if 'last_result_df' in st.session_state:
                del st.session_state.last_result_df
    with col3:
        space_info = st.empty()
        if st.session_state.current_space:
            space_info.info(f"Current space: {st.session_state.current_space}")
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Execute query
    if execute_btn and query_input:
        with st.spinner("Executing query..."):
            result = execute_query(query_input)
            
            if result:
                if result.is_succeeded():
                    st.success("Query executed successfully!")
                    
                    # Convert to DataFrame for display
                    df = result_to_dataframe(result)
                    
                    if df is not None and not df.empty:
                        # Display statistics
                        st.info(f"Returned {len(df)} rows, {len(df.columns)} columns")
                        
                        # Display data table
                        st.dataframe(df, use_container_width=True)
                        
                        # Save result for visualization
                        st.session_state.last_result_df = df
                        
                        # Show raw data
                        with st.expander("View Raw Data"):
                            st.json(df.to_dict(orient='records'))
                    else:
                        st.info("Query succeeded but no data returned")
                        if result.comment():
                            st.write(f"Message: {result.comment()}")
                else:
                    st.error(f"Query failed: {result.error_msg()}")

with tab2:
    st.header("Graph Visualization")
    
    if 'last_result_df' in st.session_state and st.session_state.last_result_df is not None:
        df = st.session_state.last_result_df
        
        # Visualization type selection
        viz_type = st.radio(
            "Select Visualization Type",
            ["Graph View", "Table View", "Statistics"],
            horizontal=True
        )
        
        if viz_type == "Graph View":
            fig = visualize_graph_from_dataframe(df)
            if fig:
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.warning("Unable to generate graph visualization from current results")
                st.dataframe(df, use_container_width=True)
        
        elif viz_type == "Table View":
            # Interactive data table
            edited_df = st.data_editor(df, use_container_width=True)
            
            # Data export options
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("Export as CSV"):
                    csv = df.to_csv(index=False).encode('utf-8')
                    st.download_button(
                        label="Download CSV",
                        data=csv,
                        file_name=f"nebula_result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv"
                    )
            
        elif viz_type == "Statistics":
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("Data Overview")
                st.markdown('<div class="metric-card">', unsafe_allow_html=True)
                st.metric("Total Rows", len(df))
                st.metric("Total Columns", len(df.columns))
                st.markdown('</div>', unsafe_allow_html=True)
                
                # Data type statistics
                st.subheader("Data Types")
                type_counts = df.dtypes.value_counts()
                st.bar_chart(type_counts)
            
            with col2:
                st.subheader("Column Information")
                column_info = []
                for col in df.columns:
                    col_type = str(df[col].dtype)
                    non_null = df[col].notnull().sum()
                    unique_count = df[col].nunique()
                    column_info.append({
                        'Column': col,
                        'Type': col_type,
                        'Non-Null': non_null,
                        'Unique': unique_count
                    })
                st.dataframe(pd.DataFrame(column_info), use_container_width=True)
    
    else:
        st.info("Please execute a query in the Query Editor tab first")

with tab3:
    st.header("System Status")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Connection Status")
        status_card = st.container()
        with status_card:
            if st.session_state.session:
                st.success("‚úÖ Connected")
                st.metric("Current Space", st.session_state.current_space or "Not selected")
            else:
                st.error("‚ùå Not connected")
        
        st.subheader("Query Statistics")
        if st.session_state.query_history:
            total_queries = len(st.session_state.query_history)
            successful_queries = sum(1 for q in st.session_state.query_history if q['success'])
            success_rate = (successful_queries / total_queries * 100) if total_queries > 0 else 0
            
            st.markdown('<div class="metric-card">', unsafe_allow_html=True)
            st.metric("Total Queries", total_queries)
            st.metric("Success Rate", f"{success_rate:.1f}%")
            st.markdown('</div>', unsafe_allow_html=True)
    
    with col2:
        st.subheader("System Information")
        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
        st.write(f"Current Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        st.write(f"Streamlit Version: {st.__version__}")
        st.write(f"Nebula Client Available: {NEBULA_AVAILABLE}")
        st.markdown('</div>', unsafe_allow_html=True)
        
        # Quick actions
        st.subheader("Quick Actions")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Clear History", use_container_width=True):
                st.session_state.query_history = []
                st.rerun()
        
        with col2:
            if st.button("Test Connection", use_container_width=True):
                if initialize_nebula_connection():
                    st.success("Connection test successful!")
                else:
                    st.error("Connection test failed!")

# Footer
st.divider()
st.caption("Nebula Graph Query Tool | Using nGQL Query Language | Data Visualization")

# Usage tips
with st.expander("üí° Usage Tips"):
    st.markdown("""
    1. **Connection Setup**: Configure Nebula Graph connection parameters in the sidebar
    2. **Query Syntax**: Use nGQL query language, supporting MATCH, FETCH, etc.
    3. **Common Commands**:
       - `SHOW SPACES` - Display all graph spaces
       - `USE <space_name>` - Switch graph space
       - `SHOW TAGS` - Display all vertex types
       - `SHOW EDGES` - Display all edge types
    4. **Visualization**: Query results automatically attempt to generate graph visualizations
    5. **History**: The sidebar saves recent query history
    
    **Note**: Ensure Nebula Graph service is running and network accessible.
    """)
