import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import networkx as nx
from datetime import datetime
import time
import traceback

# Nebula Graph imports
try:
    from nebula3.gclient.net import ConnectionPool
    from nebula3.Config import Config
    from nebula3.data.ResultSet import ResultSet
    NEBULA_AVAILABLE = True
except ImportError:
    NEBULA_AVAILABLE = False
    st.warning("Nebula3 Python client not installed. Please run: pip install nebula3-python")

# Page configuration
st.set_page_config(
    page_title="Nebula Graph Query Tool",
    page_icon="üîÆ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #4B8BBE;
        text-align: center;
        margin-bottom: 2rem;
    }
    .query-box {
        background-color: #f0f2f6;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
    }
    .result-box {
        background-color: #ffffff;
        padding: 15px;
        border-radius: 5px;
        border-left: 4px solid #4B8BBE;
        margin-top: 10px;
    }
    .stButton>button {
        background-color: #4B8BBE;
        color: white;
        font-weight: bold;
    }
    .metric-card {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #dee2e6;
    }
    .space-selector {
        background-color: #e8f4fd;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 15px;
    }
</style>
""", unsafe_allow_html=True)

# Application title
st.markdown('<h1 class="main-header">üîÆ Nebula Graph Query & Visualization Tool</h1>', unsafe_allow_html=True)

# Initialize session state
if 'connection_pool' not in st.session_state:
    st.session_state.connection_pool = None
if 'session' not in st.session_state:
    st.session_state.session = None
if 'query_history' not in st.session_state:
    st.session_state.query_history = []
if 'current_space' not in st.session_state:
    st.session_state.current_space = None
if 'available_spaces' not in st.session_state:
    st.session_state.available_spaces = []

def get_value_as_string(value_wrapper):
    """Extract string value from ValueWrapper object - Fixed version"""
    try:
        # Debug: print the type and methods available
        # print(f"ValueWrapper type: {type(value_wrapper)}")
        
        # First check if it's a ValueWrapper with get_as_string method
        if hasattr(value_wrapper, 'get_as_string'):
            return value_wrapper.get_as_string()
        
        # Check for other methods that might return the string
        if hasattr(value_wrapper, 'cast_string'):
            return value_wrapper.cast_string()
        
        # Try to get the value directly
        if hasattr(value_wrapper, '_value'):
            val = value_wrapper._value
            if hasattr(val, 'get_sVal'):
                return val.get_sVal()
            elif hasattr(val, 'get_iVal'):
                return str(val.get_iVal())
        
        # For newer versions of nebula-python
        if hasattr(value_wrapper, 'as_string'):
            return value_wrapper.as_string()
        
        # For older versions of nebula-python
        if hasattr(value_wrapper, 'get_string'):
            return value_wrapper.get_string()
        
        # Last resort: convert to string
        return str(value_wrapper)
        
    except Exception as e:
        # Return a string representation for debugging
        return f"[ValueWrapper: {type(value_wrapper).__name__}]"

def initialize_nebula_connection():
    """Initialize Nebula Graph connection"""
    if not NEBULA_AVAILABLE:
        return False
    
    try:
        config = Config()
        config.max_connection_pool_size = 10
        
        connection_pool = ConnectionPool()
        
        # Connection parameters
        addresses = [(st.session_state.get('nebula_host', '127.0.0.1'), 
                     st.session_state.get('nebula_port', 9669))]
        
        # Initialize connection pool
        if not connection_pool.init(addresses, config):
            st.error("Connection pool initialization failed")
            return False
        
        # Get session
        session = connection_pool.get_session(
            st.session_state.get('nebula_username', 'root'),
            st.session_state.get('nebula_password', 'nebula')
        )
        
        # Test connection
        result = session.execute("SHOW HOSTS")
        if not result.is_succeeded():
            st.error(f"Connection test failed: {result.error_msg()}")
            session.release()
            return False
        
        st.session_state.connection_pool = connection_pool
        st.session_state.session = session
        
        # Fetch available spaces
        fetch_available_spaces()
        
        return True
        
    except Exception as e:
        st.error(f"Connection failed: {str(e)}")
        return False

def fetch_available_spaces():
    """Fetch list of available graph spaces - Fixed version"""
    if not st.session_state.session:
        return []
    
    try:
        result = st.session_state.session.execute("SHOW SPACES")
        if result.is_succeeded():
            spaces = []
            
            # Debug: check what we got
            st.write(f"SHOW SPACES returned {result.row_size()} rows")
            
            # Get column names
            columns = result.keys()
            st.write(f"Columns: {columns}")
            
            for i, record in enumerate(result):
                try:
                    # Try different approaches to get the space name
                    values = record.values()
                    
                    # Approach 1: Try to get first column value
                    if values and len(values) > 0:
                        first_value = values[0]
                        
                        # Debug: print the value object
                        st.write(f"Row {i}, first value type: {type(first_value)}")
                        
                        # Try multiple ways to extract the value
                        space_name = None
                        
                        # Method 1: Try get_as_string
                        if hasattr(first_value, 'get_as_string'):
                            space_name = first_value.get_as_string()
                        
                        # Method 2: Try direct attribute access
                        elif hasattr(first_value, '_value'):
                            val = first_value._value
                            if hasattr(val, 'get_sVal'):
                                space_name = val.get_sVal()
                        
                        # Method 3: Try to convert to string and parse
                        else:
                            str_repr = str(first_value)
                            # Try to extract space name from string representation
                            if '[' in str_repr and ']' in str_repr:
                                # Format might be like: [b'graph_space']
                                start = str_repr.find('[') + 1
                                end = str_repr.find(']')
                                if start < end:
                                    content = str_repr[start:end]
                                    # Remove b' prefix and ' suffix if present
                                    if content.startswith("b'"):
                                        space_name = content[2:-1]
                                    elif content.startswith('b"'):
                                        space_name = content[2:-1]
                                    else:
                                        space_name = content
                            else:
                                space_name = str_repr
                        
                        if space_name and space_name not in ['NULL', 'None', '']:
                            spaces.append(space_name)
                            st.write(f"Found space: {space_name}")
                            
                except Exception as e:
                    st.write(f"Error processing row {i}: {str(e)}")
                    continue
            
            st.session_state.available_spaces = spaces
            st.write(f"Total spaces found: {len(spaces)}")
            return spaces
        else:
            st.error(f"Failed to fetch spaces: {result.error_msg()}")
            return []
    except Exception as e:
        st.error(f"Failed to fetch spaces: {str(e)}")
        st.write("Full traceback:")
        st.code(traceback.format_exc())
        return []

def switch_space(space_name):
    """Switch to a specific graph space"""
    if not st.session_state.session:
        st.error("Please connect to Nebula Graph first")
        return False
    
    try:
        # Clean the space name
        space_name = space_name.strip().replace(';', '')
        
        # Execute USE command
        result = st.session_state.session.execute(f"USE {space_name}")
        if result.is_succeeded():
            st.session_state.current_space = space_name
            return True
        else:
            st.error(f"Failed to switch space: {result.error_msg()}")
            return False
    except Exception as e:
        st.error(f"Space switch error: {str(e)}")
        return False

def execute_query(query):
    """Execute query statement"""
    if not st.session_state.session:
        st.error("Please connect to Nebula Graph first")
        return None
    
    # Clean and prepare the query
    query = query.strip()
    if not query:
        st.error("Query cannot be empty")
        return None
    
    # Check if we need to be in a specific space
    requires_space = check_query_requires_space(query)
    
    if requires_space and not st.session_state.current_space:
        st.error("This query requires a graph space to be selected. Please select a space first.")
        return None
    
    try:
        # Execute query
        start_time = time.time()
        result = st.session_state.session.execute(query)
        execution_time = time.time() - start_time
        
        # Record query history
        query_record = {
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'query': query,
            'success': result.is_succeeded(),
            'time': f"{execution_time:.3f}s",
            'space': st.session_state.current_space
        }
        st.session_state.query_history.append(query_record)
        
        # If this is a USE statement, update current space
        if query.strip().upper().startswith("USE "):
            if result.is_succeeded():
                # Extract space name from USE command
                parts = query.split()
                if len(parts) >= 2:
                    space_name = parts[1].replace(';', '')
                    st.session_state.current_space = space_name
                    st.success(f"Switched to space: {space_name}")
                    # Refresh spaces list
                    fetch_available_spaces()
        
        # If this is a CREATE SPACE or DROP SPACE command, refresh spaces
        elif query.strip().upper().startswith(("CREATE SPACE", "DROP SPACE")):
            if result.is_succeeded():
                # Wait a moment for the space to be created/dropped
                time.sleep(1)
                fetch_available_spaces()
        
        return result
        
    except Exception as e:
        st.error(f"Query execution error: {str(e)}")
        return None

def check_query_requires_space(query):
    """Check if a query requires being in a graph space"""
    query_upper = query.strip().upper()
    
    # Queries that don't require a space
    no_space_queries = [
        "SHOW SPACES",
        "CREATE SPACE",
        "DROP SPACE",
        "DESC SPACE",
        "SHOW HOSTS",
        "SHOW SESSIONS",
        "SHOW CONFIGS",
        "SHOW USERS",
        "SHOW ROLES"
    ]
    
    # Check if query starts with any of the no-space queries
    for no_space_query in no_space_queries:
        if query_upper.startswith(no_space_query):
            return False
    
    # Most other queries require a space
    return True

def result_to_dataframe(result):
    """Convert Nebula query result to DataFrame - Fixed version"""
    if not result or not result.is_succeeded():
        return None
    
    try:
        # Get column names
        column_names = result.keys()
        
        # Get data
        rows = []
        for record in result:
            row = []
            for value_wrapper in record.values():
                # Use our helper function to get the value as string
                row_value = get_value_as_string(value_wrapper)
                row.append(row_value)
            rows.append(row)
        
        # Create DataFrame
        if rows and column_names:
            df = pd.DataFrame(rows, columns=column_names)
            return df
        else:
            return pd.DataFrame()  # Return empty DataFrame
        
    except Exception as e:
        st.error(f"Result conversion error: {str(e)}")
        st.code(traceback.format_exc())
        return None

def display_result_table(result):
    """Display result in a simple table format - Alternative approach"""
    if not result or not result.is_succeeded():
        return
    
    try:
        # Get column names
        columns = result.keys()
        
        # Create data rows
        data = []
        for record in result:
            row = {}
            for i, value_wrapper in enumerate(record.values()):
                col_name = columns[i] if i < len(columns) else f"col_{i}"
                
                # Try to extract value
                try:
                    if hasattr(value_wrapper, 'get_as_string'):
                        row[col_name] = value_wrapper.get_as_string()
                    elif hasattr(value_wrapper, '_value'):
                        val = value_wrapper._value
                        if hasattr(val, 'get_sVal'):
                            row[col_name] = val.get_sVal()
                        elif hasattr(val, 'get_iVal'):
                            row[col_name] = str(val.get_iVal())
                        else:
                            row[col_name] = str(value_wrapper)
                    else:
                        row[col_name] = str(value_wrapper)
                except:
                    row[col_name] = str(value_wrapper)
            
            data.append(row)
        
        # Display as DataFrame
        if data:
            df = pd.DataFrame(data)
            st.dataframe(df, use_container_width=True)
            return df
        else:
            st.info("No data returned")
            return None
            
    except Exception as e:
        st.error(f"Error displaying result: {str(e)}")
        return None

def visualize_graph_from_dataframe(df):
    """Create graph visualization from DataFrame"""
    if df is None or df.empty:
        return None
    
    try:
        # Try to identify nodes and edges
        nodes = set()
        edges = []
        
        # Look for vertex and edge patterns in the data
        for idx, row in df.iterrows():
            for col in df.columns:
                cell_value = str(row[col])
                
                # Check for vertex pattern (e.g., "Vertex(some_id)")
                if cell_value.startswith("Vertex(") and ")" in cell_value:
                    node_id = cell_value.split("Vertex(")[1].split(")")[0]
                    nodes.add(node_id)
                
                # Check for edge pattern (e.g., "Edge(src->dst)")
                elif cell_value.startswith("Edge(") and ")" in cell_value:
                    edge_content = cell_value.split("Edge(")[1].split(")")[0]
                    if "->" in edge_content:
                        src, dst = edge_content.split("->")
                        edges.append((src, dst))
                        nodes.add(src)
                        nodes.add(dst)
        
        # If we found nodes and edges, create a graph
        if nodes:
            G = nx.Graph()
            
            # Add nodes
            for node in nodes:
                G.add_node(node)
            
            # Add edges
            for src, dst in edges:
                G.add_edge(src, dst)
            
            # Create positions for nodes
            pos = nx.spring_layout(G, seed=42)
            
            # Create Plotly figure
            edge_x = []
            edge_y = []
            for edge in G.edges():
                x0, y0 = pos[edge[0]]
                x1, y1 = pos[edge[1]]
                edge_x.extend([x0, x1, None])
                edge_y.extend([y0, y1, None])
            
            edge_trace = go.Scatter(
                x=edge_x, y=edge_y,
                line=dict(width=1, color='#888'),
                hoverinfo='none',
                mode='lines',
                name='Edges'
            )
            
            node_x = []
            node_y = []
            node_text = []
            for node in G.nodes():
                x, y = pos[node]
                node_x.append(x)
                node_y.append(y)
                node_text.append(f"Node: {node}")
            
            node_trace = go.Scatter(
                x=node_x, y=node_y,
                mode='markers+text',
                hoverinfo='text',
                text=list(G.nodes()),
                textposition="bottom center",
                marker=dict(
                    showscale=True,
                    colorscale='YlGnBu',
                    size=20,
                    color=[],
                    line_width=2
                ),
                name='Nodes'
            )
            
            fig = go.Figure(data=[edge_trace, node_trace],
                           layout=go.Layout(
                               title='Graph Visualization',
                               titlefont_size=16,
                               showlegend=False,
                               hovermode='closest',
                               margin=dict(b=20,l=5,r=5,t=40),
                               xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                               yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
                           ))
            
            return fig
        else:
            # If no graph data found, create a simple visualization of the dataframe
            st.info("No graph data found in results. Showing data as table.")
            return None
            
    except Exception as e:
        st.warning(f"Could not create graph visualization: {str(e)}")
        return None

# Sidebar - Connection Configuration
with st.sidebar:
    st.header("üîó Connection Configuration")
    
    # Connection parameters
    nebula_host = st.text_input("Nebula Graph Address", value="127.0.0.1", key="nebula_host")
    nebula_port = st.number_input("Port", value=9669, min_value=1, max_value=65535, key="nebula_port")
    nebula_username = st.text_input("Username", value="root", key="nebula_username")
    nebula_password = st.text_input("Password", value="nebula", type="password", key="nebula_password")
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button("Connect to Nebula", use_container_width=True, type="primary"):
            with st.spinner("Connecting..."):
                if initialize_nebula_connection():
                    st.success("Connected successfully!")
    with col2:
        if st.button("Disconnect", use_container_width=True):
            if st.session_state.session:
                st.session_state.session.release()
                st.session_state.connection_pool.close()
                st.session_state.session = None
                st.session_state.connection_pool = None
                st.session_state.current_space = None
                st.session_state.available_spaces = []
                st.info("Disconnected")
    
    st.divider()
    
    # Space Selection
    st.header("üåå Space Management")
    
    if st.session_state.session:
        st.markdown('<div class="space-selector">', unsafe_allow_html=True)
        
        current_space = st.session_state.current_space or "No space selected"
        st.write(f"**Current Space:** `{current_space}`")
        
        # Refresh spaces button
        if st.button("üîÑ Refresh Spaces", use_container_width=True):
            with st.spinner("Fetching spaces..."):
                fetch_available_spaces()
                st.rerun()
        
        # Show available spaces
        if st.session_state.available_spaces:
            # Space selection dropdown
            selected_space = st.selectbox(
                "Select a Graph Space",
                options=[""] + st.session_state.available_spaces,
                index=0,
                help="Select a graph space to work with"
            )
            
            if selected_space:
                if st.button(f"Switch to {selected_space}", use_container_width=True):
                    if switch_space(selected_space):
                        st.success(f"Switched to space: {selected_space}")
                        st.rerun()
            
            st.write(f"**Available spaces ({len(st.session_state.available_spaces)}):**")
            for space in st.session_state.available_spaces:
                if space == st.session_state.current_space:
                    st.markdown(f"‚úÖ `{space}`")
                else:
                    st.markdown(f"`{space}`")
        else:
            st.info("No spaces found. Create a space first.")
            if st.button("Show CREATE SPACE Example", use_container_width=True):
                st.code("CREATE SPACE test_space(vid_type=FIXED_STRING(30))")
        
        st.markdown('</div>', unsafe_allow_html=True)
    else:
        st.info("Connect to see available spaces")
    
    st.divider()
    
    # Query History
    st.header("üìú Query History")
    if st.session_state.query_history:
        for i, record in enumerate(reversed(st.session_state.query_history[-5:])):
            with st.expander(f"{record['timestamp']} - {record['query'][:50]}..."):
                st.code(record['query'])
                status = "‚úÖ Success" if record['success'] else "‚ùå Failed"
                st.caption(f"Status: {status}")
                st.caption(f"Time: {record['time']}")
                if record.get('space'):
                    st.caption(f"Space: {record['space']}")
    else:
        st.caption("No query history yet")
    
    st.divider()
    
    # Query Examples
    st.header("üí° Query Examples")
    examples = {
        "Show all spaces": "SHOW SPACES",
        "Create test space": "CREATE SPACE IF NOT EXISTS test_space(vid_type=FIXED_STRING(30))",
        "Show tags": "SHOW TAGS",
        "Show edge types": "SHOW EDGES",
        "Simple vertex query": "MATCH (v) RETURN v LIMIT 5",
        "Simple edge query": "MATCH ()-[e]->() RETURN e LIMIT 5"
    }
    
    selected_example = st.selectbox("Select example query", list(examples.keys()))
    if st.button("Use Example", use_container_width=True):
        st.session_state.example_query = examples[selected_example]

# Main Interface
tab1, tab2, tab3 = st.tabs(["üìù Query Editor", "üìä Data Visualization", "üìà System Status"])

with tab1:
    st.markdown('<div class="query-box">', unsafe_allow_html=True)
    
    # Space warning
    if st.session_state.session and not st.session_state.current_space:
        st.warning("‚ö†Ô∏è No graph space selected. Most queries require a space. Select one from the sidebar or use: `USE your_space_name;`")
    
    # Query input
    query_input = st.text_area(
        "Enter Query Statement",
        height=150,
        value=st.session_state.get('example_query', ''),
        placeholder="Enter your nGQL query, e.g.:\nUSE your_space_name;\nMATCH (v) RETURN v LIMIT 10",
        key="query_input"
    )
    
    col1, col2, col3 = st.columns([1, 1, 2])
    with col1:
        execute_btn = st.button("üöÄ Execute Query", use_container_width=True, type="primary")
    with col2:
        if st.button("üîÑ Clear Results", use_container_width=True):
            if 'last_result_df' in st.session_state:
                del st.session_state.last_result_df
    with col3:
        space_info = st.empty()
        if st.session_state.current_space:
            space_info.success(f"‚úÖ Current space: **{st.session_state.current_space}**")
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Execute query
    if execute_btn and query_input:
        with st.spinner("Executing query..."):
            result = execute_query(query_input)
            
            if result:
                if result.is_succeeded():
                    st.success("Query executed successfully!")
                    
                    # Try to display result using our table function first
                    df = display_result_table(result)
                    
                    if df is not None and not df.empty:
                        # Display statistics
                        st.info(f"Returned {len(df)} rows, {len(df.columns)} columns")
                        
                        # Save result for visualization
                        st.session_state.last_result_df = df
                        
                        # Show raw data
                        with st.expander("View Raw Data"):
                            st.json(df.to_dict(orient='records'))
                    else:
                        st.info("Query succeeded but no data returned")
                        if hasattr(result, 'comment') and result.comment():
                            st.write(f"Message: {result.comment()}")
                else:
                    error_msg = result.error_msg()
                    st.error(f"Query failed: {error_msg}")
                    
                    # Provide helpful suggestions based on error
                    if "space was not chosen" in error_msg.lower():
                        st.info("üí° **Solution:** You need to select a graph space first. Either:")
                        st.markdown("1. Select a space from the sidebar dropdown")
                        st.markdown("2. Add `USE your_space_name;` at the beginning of your query")
                        st.markdown("3. Create a new space with `CREATE SPACE your_space_name(...)`")

with tab2:
    st.header("Data Visualization")
    
    if 'last_result_df' in st.session_state and st.session_state.last_result_df is not None:
        df = st.session_state.last_result_df
        
        # Visualization type selection
        viz_type = st.radio(
            "Select Visualization Type",
            ["Table View", "Graph View", "Statistics"],
            horizontal=True
        )
        
        if viz_type == "Table View":
            # Interactive data table
            edited_df = st.data_editor(df, use_container_width=True)
            
            # Data export options
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("Export as CSV"):
                    csv = df.to_csv(index=False).encode('utf-8')
                    st.download_button(
                        label="Download CSV",
                        data=csv,
                        file_name=f"nebula_result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv"
                    )
        
        elif viz_type == "Graph View":
            fig = visualize_graph_from_dataframe(df)
            if fig:
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.warning("No graph data found in results. Showing table view instead:")
                st.dataframe(df, use_container_width=True)
            
        elif viz_type == "Statistics":
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("Data Overview")
                st.markdown('<div class="metric-card">', unsafe_allow_html=True)
                st.metric("Total Rows", len(df))
                st.metric("Total Columns", len(df.columns))
                st.markdown('</div>', unsafe_allow_html=True)
                
                # Data type statistics
                st.subheader("Data Types")
                type_counts = df.dtypes.value_counts()
                if not type_counts.empty:
                    st.bar_chart(type_counts)
                else:
                    st.info("No type information available")
            
            with col2:
                st.subheader("Column Information")
                column_info = []
                for col in df.columns:
                    col_type = str(df[col].dtype)
                    non_null = df[col].notnull().sum()
                    unique_count = df[col].nunique()
                    column_info.append({
                        'Column': col,
                        'Type': col_type,
                        'Non-Null': non_null,
                        'Unique': unique_count
                    })
                if column_info:
                    st.dataframe(pd.DataFrame(column_info), use_container_width=True)
    
    else:
        st.info("Please execute a query in the Query Editor tab first")

with tab3:
    st.header("System Status")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Connection Status")
        status_card = st.container()
        with status_card:
            if st.session_state.session:
                st.success("‚úÖ Connected")
                st.metric("Current Space", st.session_state.current_space or "Not selected")
                if st.session_state.current_space:
                    st.markdown(f"Space selected: `{st.session_state.current_space}`")
            else:
                st.error("‚ùå Not connected")
        
        st.subheader("Query Statistics")
        if st.session_state.query_history:
            total_queries = len(st.session_state.query_history)
            successful_queries = sum(1 for q in st.session_state.query_history if q['success'])
            success_rate = (successful_queries / total_queries * 100) if total_queries > 0 else 0
            
            st.markdown('<div class="metric-card">', unsafe_allow_html=True)
            st.metric("Total Queries", total_queries)
            st.metric("Success Rate", f"{success_rate:.1f}%")
            st.markdown('</div>', unsafe_allow_html=True)
    
    with col2:
        st.subheader("System Information")
        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
        st.write(f"Current Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        st.write(f"Streamlit Version: {st.__version__}")
        st.write(f"Nebula Client Available: {NEBULA_AVAILABLE}")
        st.write(f"Available Spaces: {len(st.session_state.available_spaces)}")
        if st.session_state.available_spaces:
            st.write("Spaces:", ", ".join(st.session_state.available_spaces))
        st.markdown('</div>', unsafe_allow_html=True)
        
        # Quick actions
        st.subheader("Quick Actions")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Refresh Spaces", use_container_width=True):
                if st.session_state.session:
                    fetch_available_spaces()
                    st.rerun()
                else:
                    st.error("Not connected")
        
        with col2:
            if st.button("Clear History", use_container_width=True):
                st.session_state.query_history = []
                st.rerun()

# Footer
st.divider()
st.caption("Nebula Graph Query Tool | Using nGQL Query Language | Data Visualization")

# Usage tips
with st.expander("üí° Debug Information & Tips"):
    st.markdown("""
    ### Debug Information
    
    If you're having issues with the ValueWrapper object:
    
    1. **Check your nebula-python version**:
       ```bash
       pip show nebula3-python
       ```
    
    2. **Common methods on ValueWrapper**:
       - `get_as_string()` - For newer versions
       - `_value.get_sVal()` - For accessing underlying value
       - `cast_string()` - Alternative method
       - Direct string conversion: `str(value_wrapper)`
    
    3. **Test with simple queries first**:
       ```sql
       SHOW HOSTS  -- Should always work
       SHOW SPACES -- Might need parsing
       ```
    
    ### Manual Space Management
    
    If automatic space detection fails, you can manually:
    
    1. **Create a space**:
       ```sql
       CREATE SPACE test_space(vid_type=FIXED_STRING(30))
       ```
    
    2. **Switch to it**:
       ```sql
       USE test_space
       ```
    
    3. **Then run your queries**
    """)

# Add manual space input option
with st.expander("üîß Manual Space Management"):
    manual_space = st.text_input("Enter Space Name", placeholder="graph_space")
    
    if manual_space:
        if st.button(f"Manually switch to {manual_space}", use_container_width=True):
            if switch_space(manual_space):
                st.success(f"Manually switched to space: {manual_space}")
                # Add to available spaces if not already there
                if manual_space not in st.session_state.available_spaces:
                    st.session_state.available_spaces.append(manual_space)
                st.rerun()
