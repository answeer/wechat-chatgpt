import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import networkx as nx
from datetime import datetime
import time
from nebula3.gclient.net import ConnectionPool
from nebula3.Config import Config

# Page configuration
st.set_page_config(
    page_title="Nebula Graph Query Tool",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #4B8BBE;
        text-align: center;
        margin-bottom: 2rem;
    }
    .query-box {
        background-color: #f0f2f6;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
    }
    .result-box {
        background-color: #ffffff;
        padding: 15px;
        border-radius: 5px;
        border-left: 4px solid #4B8BBE;
        margin-top: 10px;
    }
    .stButton>button {
        background-color: #4B8BBE;
        color: white;
        font-weight: bold;
    }
    .metric-card {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #dee2e6;
    }
    .space-selector {
        background-color: #e8f4fd;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 15px;
    }
</style>
""", unsafe_allow_html=True)

# Application title
st.markdown('<h1 class="main-header">Nebula Graph Query & Visualization Tool</h1>', unsafe_allow_html=True)

# Initialize session state
if 'connection_pool' not in st.session_state:
    st.session_state.connection_pool = None
if 'session' not in st.session_state:
    st.session_state.session = None
if 'query_history' not in st.session_state:
    st.session_state.query_history = []
if 'current_space' not in st.session_state:
    st.session_state.current_space = None
if 'available_spaces' not in st.session_state:
    st.session_state.available_spaces = []

def get_value_as_string(value_wrapper):
    """Extract string value from ValueWrapper object - Fixed version for all data types"""
    try:
        # Get the underlying value
        val = value_wrapper
        
        # First try to check if it's a complex type (Vertex, Edge, Path)
        if hasattr(val, 'is_vertex'):
            # It's a Vertex
            vid = str(val.get_id())
            tags = []
            if hasattr(val, 'tags') and val.tags():
                for tag in val.tags():
                    tags.append(str(tag))
            return f"Vertex({vid})[Tags: {', '.join(tags)}]"
        
        elif hasattr(val, 'is_edge'):
            # It's an Edge
            src = str(val.src_vertex_id())
            dst = str(val.dst_vertex_id())
            edge_name = str(val.edge_name()) if hasattr(val, 'edge_name') else "edge"
            return f"Edge[{edge_name}]({src}->{dst})"
        
        elif hasattr(val, 'is_path'):
            # It's a Path
            return "Path(...)"  # Simplified for now
        
        elif hasattr(val, 'is_list'):
            # It's a List
            items = []
            for item in val.as_list():
                items.append(get_value_as_string(item))
            return f"[{', '.join(items)}]"
        
        elif hasattr(val, 'is_set'):
            # It's a Set
            items = []
            for item in val.as_set():
                items.append(get_value_as_string(item))
            return f"{{{', '.join(items)}}}"
        
        elif hasattr(val, 'is_map'):
            # It's a Map
            items = []
            for k, v in val.as_map().items():
                items.append(f"{k}: {get_value_as_string(v)}")
            return f"{{{', '.join(items)}}}"
        
        # For basic types, use the as_string method
        if hasattr(val, 'as_string'):
            result = val.as_string()
        elif hasattr(val, 'get_string'):
            result = val.get_string()
        else:
            result = str(val)
        
        # Handle bytes
        if isinstance(result, bytes):
            try:
                return result.decode('utf-8')
            except:
                return str(result)
        
        # Clean up the result
        if isinstance(result, str):
            # Remove b' prefix if present
            if result.startswith("b'") and result.endswith("'"):
                result = result[2:-1]
            elif result.startswith('b"') and result.endswith('"'):
                result = result[2:-1]
        
        return str(result)
        
    except Exception as e:
        # Fallback: try direct string conversion
        try:
            return str(value_wrapper)
        except:
            return f"[Error parsing value: {str(e)}]"

def initialize_nebula_connection():
    """Initialize Nebula Graph connection"""
    
    try:
        config = Config()
        config.max_connection_pool_size = 10
        
        connection_pool = ConnectionPool()
        
        # Connection parameters
        addresses = [(st.session_state.get('nebula_host', '127.0.0.1'), 
                     st.session_state.get('nebula_port', 9669))]
        
        # Initialize connection pool
        if not connection_pool.init(addresses, config):
            st.error("Connection pool initialization failed")
            return False
        
        # Get session
        session = connection_pool.get_session(
            st.session_state.get('nebula_username', 'root'),
            st.session_state.get('nebula_password', 'nebula')
        )
        
        # Test connection
        result = session.execute("SHOW HOSTS")
        if not result.is_succeeded():
            st.error(f"Connection test failed: {result.error_msg()}")
            session.release()
            return False
        
        st.session_state.connection_pool = connection_pool
        st.session_state.session = session
        
        # Fetch available spaces
        fetch_available_spaces()
        
        return True
        
    except Exception as e:
        st.error(f"Connection failed: {str(e)}")
        return False

def fetch_available_spaces():
    """Fetch list of available graph spaces"""
    if not st.session_state.session:
        return []
    
    try:
        result = st.session_state.session.execute("SHOW SPACES")
        if result.is_succeeded():
            spaces = []
            
            for record in result:
                try:
                    # Get the first column value which should be the space name
                    if record.values():
                        value_wrapper = record.values()[0]
                        space_name = get_value_as_string(value_wrapper)
                        
                        # Clean up the space name
                        if space_name and space_name != "NULL" and space_name != "None":
                            spaces.append(space_name)
                            
                except Exception as e:
                    continue
            
            st.session_state.available_spaces = spaces
            return spaces
        else:
            st.error(f"Failed to fetch spaces: {result.error_msg()}")
            return []
    except Exception as e:
        st.error(f"Failed to fetch spaces: {str(e)}")
        return []

def switch_space(space_name):
    """Switch to a specific graph space"""
    if not st.session_state.session:
        st.error("Please connect to Nebula Graph first")
        return False
    
    try:
        # Clean the space name
        space_name = space_name.strip().replace(';', '')
        
        # Execute USE command
        result = st.session_state.session.execute(f"USE {space_name}")
        if result.is_succeeded():
            st.session_state.current_space = space_name
            return True
        else:
            st.error(f"Failed to switch space: {result.error_msg()}")
            return False
    except Exception as e:
        st.error(f"Space switch error: {str(e)}")
        return False

def execute_query(query):
    """Execute query statement"""
    if not st.session_state.session:
        st.error("Please connect to Nebula Graph first")
        return None
    
    # Clean and prepare the query
    query = query.strip()
    if not query:
        st.error("Query cannot be empty")
        return None
    
    # Check if we need to be in a specific space
    requires_space = check_query_requires_space(query)
    
    if requires_space and not st.session_state.current_space:
        st.error("This query requires a graph space to be selected. Please select a space first.")
        return None
    
    try:
        # Execute query
        start_time = time.time()
        result = st.session_state.session.execute(query)
        execution_time = time.time() - start_time
        
        # Record query history
        query_record = {
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'query': query,
            'success': result.is_succeeded(),
            'time': f"{execution_time:.3f}s",
            'space': st.session_state.current_space
        }
        st.session_state.query_history.append(query_record)
        
        # If this is a USE statement, update current space
        if query.strip().upper().startswith("USE "):
            if result.is_succeeded():
                # Extract space name from USE command
                parts = query.split()
                if len(parts) >= 2:
                    space_name = parts[1].replace(';', '')
                    st.session_state.current_space = space_name
                    st.success(f"Switched to space: {space_name}")
                    # Refresh spaces list
                    fetch_available_spaces()
        
        # If this is a CREATE SPACE or DROP SPACE command, refresh spaces
        elif query.strip().upper().startswith(("CREATE SPACE", "DROP SPACE")):
            if result.is_succeeded():
                # Wait a moment for the space to be created/dropped
                time.sleep(1)
                fetch_available_spaces()
        
        return result
        
    except Exception as e:
        st.error(f"Query execution error: {str(e)}")
        return None

def check_query_requires_space(query):
    """Check if a query requires being in a graph space"""
    query_upper = query.strip().upper()
    
    # Queries that don't require a space
    no_space_queries = [
        "SHOW SPACES",
        "CREATE SPACE",
        "DROP SPACE",
        "DESC SPACE",
        "SHOW HOSTS",
        "SHOW SESSIONS",
        "SHOW CONFIGS",
        "SHOW USERS",
        "SHOW ROLES"
    ]
    
    # Check if query starts with any of the no-space queries
    for no_space_query in no_space_queries:
        if query_upper.startswith(no_space_query):
            return False
    
    # Most other queries require a space
    return True

def display_result_table(result):
    """Display result in a simple table format"""
    if not result or not result.is_succeeded():
        return None
    
    try:
        # Get column names
        columns = result.keys()
        
        # Create data rows
        data = []
        for record in result:
            row = {}
            for i, value_wrapper in enumerate(record.values()):
                col_name = columns[i] if i < len(columns) else f"col_{i}"
                
                # Get the value as string using our fixed function
                cell_value = get_value_as_string(value_wrapper)
                
                row[col_name] = cell_value
            
            data.append(row)
        
        # Display as DataFrame
        if data:
            df = pd.DataFrame(data)
            return df
        else:
            return pd.DataFrame()  # Return empty DataFrame
            
    except Exception as e:
        st.error(f"Error displaying result: {str(e)}")
        return None

def visualize_graph_from_dataframe(df):
    """Create graph visualization from DataFrame"""
    if df is None or df.empty:
        return None
    
    try:
        # Try to identify nodes and edges from the data
        nodes = set()
        edges = []
        node_labels = {}
        
        for idx, row in df.iterrows():
            for col in df.columns:
                cell_value = str(row[col])
                
                # Look for Vertex patterns
                if "Vertex(" in cell_value:
                    # Extract vertex ID from Vertex(id) pattern
                    try:
                        if "Vertex(" in cell_value and ")" in cell_value:
                            vertex_part = cell_value.split("Vertex(")[1].split(")")[0]
                            node_id = vertex_part.split("[")[0].strip()  # Get ID part
                            if node_id:
                                nodes.add(node_id)
                                
                                # Try to extract tags for labeling
                                if "Tags:" in cell_value:
                                    tags_part = cell_value.split("Tags:")[1].split("]")[0]
                                    node_labels[node_id] = f"Vertex: {node_id}\nTags: {tags_part}"
                                else:
                                    node_labels[node_id] = f"Vertex: {node_id}"
                    except:
                        pass
                
                # Look for Edge patterns
                elif "Edge[" in cell_value and "]->" in cell_value:
                    try:
                        # Extract src and dst from Edge[type](src->dst) pattern
                        if "]->" in cell_value:
                            edge_part = cell_value.split("]->")[0]
                            src_part = edge_part.split("(")[-1]
                            
                            dst_part = cell_value.split("]->")[1].split(")")[0]
                            
                            if src_part and dst_part:
                                src = src_part.strip()
                                dst = dst_part.strip()
                                edges.append((src, dst, cell_value))
                                nodes.add(src)
                                nodes.add(dst)
                    except:
                        pass
        
        # If we found nodes, create a graph
        if nodes:
            G = nx.Graph()
            
            # Add nodes
            for node in nodes:
                G.add_node(node, label=node_labels.get(node, node))
            
            # Add edges
            for src, dst, label in edges:
                G.add_edge(src, dst, label=label)
            
            # Create positions for nodes
            pos = nx.spring_layout(G, seed=42)
            
            # Create Plotly figure
            edge_x = []
            edge_y = []
            edge_labels = []
            
            for edge in G.edges():
                x0, y0 = pos[edge[0]]
                x1, y1 = pos[edge[1]]
                edge_x.extend([x0, x1, None])
                edge_y.extend([y0, y1, None])
                
                # Find the edge label
                edge_label = ""
                for src_e, dst_e, label_e in edges:
                    if src_e == edge[0] and dst_e == edge[1]:
                        edge_label = label_e
                        break
                
                edge_labels.append(edge_label)
            
            edge_trace = go.Scatter(
                x=edge_x, y=edge_y,
                line=dict(width=2, color='#888'),
                hoverinfo='text',
                mode='lines',
                name='Edges'
            )
            
            node_x = []
            node_y = []
            node_text = []
            node_colors = []
            
            for i, node in enumerate(G.nodes()):
                x, y = pos[node]
                node_x.append(x)
                node_y.append(y)
                node_text.append(node_labels.get(node, node))
                node_colors.append(i)  # Color by index
            
            node_trace = go.Scatter(
                x=node_x, y=node_y,
                mode='markers+text',
                hoverinfo='text',
                text=[str(n) for n in G.nodes()],
                textposition="bottom center",
                hovertext=node_text,
                marker=dict(
                    showscale=True,
                    colorscale='Viridis',
                    size=25,
                    color=node_colors,
                    line=dict(width=2, color='white')
                ),
                name='Nodes'
            )
            
            fig = go.Figure(data=[edge_trace, node_trace],
                           layout=go.Layout(
                               title='Graph Visualization',
                               titlefont_size=16,
                               showlegend=True,
                               hovermode='closest',
                               margin=dict(b=20,l=5,r=5,t=40),
                               xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                               yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
                           ))
            
            return fig
        else:
            return None
            
    except Exception as e:
        st.warning(f"Could not create graph visualization: {str(e)}")
        return None

# Sidebar - Connection Configuration
with st.sidebar:
    st.header("Connection Configuration")
    
    # Connection parameters
    nebula_host = st.text_input("Nebula Graph Address", value="127.0.0.1", key="nebula_host")
    nebula_port = st.number_input("Port", value=9669, min_value=1, max_value=65535, key="nebula_port")
    nebula_username = st.text_input("Username", value="root", key="nebula_username")
    nebula_password = st.text_input("Password", value="nebula", type="password", key="nebula_password")
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button("Connect to Nebula", use_container_width=True, type="primary"):
            with st.spinner("Connecting..."):
                if initialize_nebula_connection():
                    st.success("Connected successfully!")
    with col2:
        if st.button("Disconnect", use_container_width=True):
            if st.session_state.session:
                st.session_state.session.release()
                if st.session_state.connection_pool:
                    st.session_state.connection_pool.close()
                st.session_state.session = None
                st.session_state.connection_pool = None
                st.session_state.current_space = None
                st.session_state.available_spaces = []
                st.info("Disconnected")
    
    st.divider()
    
    # Space Selection
    st.header("Space Management")
    
    if st.session_state.session:
        st.markdown('<div class="space-selector">', unsafe_allow_html=True)
        
        current_space = st.session_state.current_space or "No space selected"
        st.write(f"**Current Space:** `{current_space}`")
        
        # Refresh spaces button
        if st.button("Refresh Spaces", use_container_width=True):
            with st.spinner("Fetching spaces..."):
                fetch_available_spaces()
                st.rerun()
        
        # Show available spaces
        if st.session_state.available_spaces:
            # Space selection dropdown
            selected_space = st.selectbox(
                "Select a Graph Space",
                options=[""] + st.session_state.available_spaces,
                index=0,
                help="Select a graph space to work with"
            )
            
            if selected_space:
                if st.button(f"Switch to {selected_space}", use_container_width=True):
                    if switch_space(selected_space):
                        st.success(f"Switched to space: {selected_space}")
                        st.rerun()
            
        else:
            st.info("No spaces found. Create a space first.")
            if st.button("Show CREATE SPACE Example", use_container_width=True):
                st.code("CREATE SPACE IF NOT EXISTS test_space(vid_type=FIXED_STRING(30));")
        
        st.markdown('</div>', unsafe_allow_html=True)
    else:
        st.info("Connect to see available spaces")
    
    st.divider()
    
    # Query Examples
    st.header("Query Examples")
    
    example_queries = {
        "Show Spaces": "SHOW SPACES;",
        "Create Space": "CREATE SPACE IF NOT EXISTS test_space(vid_type=FIXED_STRING(30));",
        "Show Tags": "SHOW TAGS;",
        "Show Edges": "SHOW EDGES;",
        "Simple MATCH": "MATCH (v) RETURN v LIMIT 10;",
        "Count Vertices": "MATCH (v) RETURN count(v) AS vertex_count;"
    }
    
    selected_example = st.selectbox("Choose an example:", list(example_queries.keys()))
    if st.button("Load Example"):
        st.session_state.example_query = example_queries[selected_example]
        st.rerun()
    
    st.divider()
    
    # Query History
    st.header("Query History")
    if st.session_state.query_history:
        for i, record in enumerate(reversed(st.session_state.query_history[-5:])):
            with st.expander(f"{record['timestamp']} - {record['query'][:50]}..."):
                st.code(record['query'])
                status = "✅ Success" if record['success'] else "❌ Failed"
                st.caption(f"Status: {status}")
                st.caption(f"Time: {record['time']}")
                if record.get('space'):
                    st.caption(f"Space: {record['space']}")
    else:
        st.caption("No query history yet")
    
    st.divider()

# Main Interface
tab1, tab2, tab3 = st.tabs(["Query Editor", "Data Visualization", "System Status"])

with tab1:
    st.markdown('<div class="query-box">', unsafe_allow_html=True)
    
    # Space warning
    if st.session_state.session and not st.session_state.current_space:
        st.warning("No graph space selected. Most queries require a space. Select one from the sidebar or use: `USE your_space_name;`")
    
    # Query input
    query_input = st.text_area(
        "Enter Query Statement",
        height=150,
        value=st.session_state.get('example_query', ''),
        placeholder="Enter your nGQL query, e.g.:\nUSE your_space_name;\nMATCH (v) RETURN v LIMIT 10",
        key="query_input"
    )
    
    col1, col2, col3 = st.columns([1, 1, 2])
    with col1:
        execute_btn = st.button("Execute Query", use_container_width=True, type="primary")
    with col2:
        if st.button("Clear Results", use_container_width=True):
            if 'last_result_df' in st.session_state:
                del st.session_state.last_result_df
    with col3:
        space_info = st.empty()
        if st.session_state.current_space:
            space_info.success(f"Current space: **{st.session_state.current_space}**")
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Execute query
    if execute_btn and query_input:
        with st.spinner("Executing query..."):
            result = execute_query(query_input)
            
            if result:
                if result.is_succeeded():
                    st.success("Query executed successfully!")
                    
                    # Display result using our table function
                    df = display_result_table(result)
                    
                    if df is not None and not df.empty:
                        # Display statistics
                        st.info(f"Returned {len(df)} rows, {len(df.columns)} columns")
                        
                        # Display data table
                        st.dataframe(df, use_container_width=True)
                        
                        # Save result for visualization
                        st.session_state.last_result_df = df
                        
                        # Show raw data
                        with st.expander("View Raw Data"):
                            st.json(df.to_dict(orient='records'))
                    else:
                        st.info("Query succeeded but no data returned")
                        if hasattr(result, 'comment') and result.comment():
                            st.write(f"Message: {result.comment()}")
                else:
                    error_msg = result.error_msg()
                    st.error(f"Query failed: {error_msg}")
                    
                    # Provide helpful suggestions based on error
                    if "space was not chosen" in error_msg.lower():
                        st.info("**Solution:** You need to select a graph space first. Either:")
                        st.markdown("1. Select a space from the sidebar dropdown")
                        st.markdown("2. Add `USE your_space_name;` at the beginning of your query")
                        st.markdown("3. Create a new space with `CREATE SPACE your_space_name(...)`")

with tab2:
    st.header("Data Visualization")
    
    if 'last_result_df' in st.session_state and st.session_state.last_result_df is not None:
        df = st.session_state.last_result_df
        
        # Visualization type selection
        viz_type = st.radio(
            "Select Visualization Type",
            ["Table View", "Graph View", "Statistics"],
            horizontal=True
        )
        
        if viz_type == "Table View":
            # Interactive data table
            edited_df = st.data_editor(df, use_container_width=True)
            
            # Data export options
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("Export as CSV"):
                    csv = df.to_csv(index=False).encode('utf-8')
                    st.download_button(
                        label="Download CSV",
                        data=csv,
                        file_name=f"nebula_result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv"
                    )
        
        elif viz_type == "Graph View":
            fig = visualize_graph_from_dataframe(df)
            if fig:
                st.plotly_chart(fig, use_container_width=True)
                st.info("Graph visualization showing Vertex and Edge relationships")
            else:
                st.info("No graph data found in results. Showing table view instead:")
                st.dataframe(df, use_container_width=True)
            
        elif viz_type == "Statistics":
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("Data Overview")
                st.markdown('<div class="metric-card">', unsafe_allow_html=True)
                st.metric("Total Rows", len(df))
                st.metric("Total Columns", len(df.columns))
                st.markdown('</div>', unsafe_allow_html=True)
                
                # Data type statistics
                st.subheader("Data Types")
                type_counts = df.dtypes.value_counts()
                if not type_counts.empty:
                    st.bar_chart(type_counts)
                else:
                    st.info("No type information available")
            
            with col2:
                st.subheader("Column Information")
                column_info = []
                for col in df.columns:
                    col_type = str(df[col].dtype)
                    non_null = df[col].notnull().sum()
                    unique_count = df[col].nunique()
                    column_info.append({
                        'Column': col,
                        'Type': col_type,
                        'Non-Null': non_null,
                        'Unique': unique_count
                    })
                if column_info:
                    st.dataframe(pd.DataFrame(column_info), use_container_width=True)
    
    else:
        st.info("Please execute a query in the Query Editor tab first")

with tab3:
    st.header("System Status")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Connection Status")
        status_card = st.container()
        with status_card:
            if st.session_state.session:
                st.success("Connected")
                st.metric("Current Space", st.session_state.current_space or "Not selected")
                if st.session_state.current_space:
                    st.markdown(f"Space selected: `{st.session_state.current_space}`")
            else:
                st.error("Not connected")
        
        st.subheader("Query Statistics")
        if st.session_state.query_history:
            total_queries = len(st.session_state.query_history)
            successful_queries = sum(1 for q in st.session_state.query_history if q['success'])
            success_rate = (successful_queries / total_queries * 100) if total_queries > 0 else 0
            
            st.markdown('<div class="metric-card">', unsafe_allow_html=True)
            st.metric("Total Queries", total_queries)
            st.metric("Success Rate", f"{success_rate:.1f}%")
            st.markdown('</div>', unsafe_allow_html=True)
    
    with col2:
        st.subheader("System Information")
        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
        st.write(f"Current Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        st.write(f"Streamlit Version: {st.__version__}")
        st.write(f"Available Spaces: {len(st.session_state.available_spaces)}")
        
        if st.session_state.available_spaces:
            spaces_display = []
            for space in st.session_state.available_spaces:
                if isinstance(space, bytes):
                    try:
                        spaces_display.append(space.decode('utf-8'))
                    except:
                        spaces_display.append(str(space))
                else:
                    spaces_display.append(str(space))
            
            if spaces_display:
                st.write("Spaces:", ", ".join(spaces_display[:5]))
                if len(spaces_display) > 5:
                    st.write(f"... and {len(spaces_display) - 5} more")
        st.markdown('</div>', unsafe_allow_html=True)
        
        # Quick actions
        st.subheader("Quick Actions")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Refresh Spaces", use_container_width=True):
                if st.session_state.session:
                    fetch_available_spaces()
                    st.rerun()
                else:
                    st.error("Not connected")
        
        with col2:
            if st.button("Clear History", use_container_width=True):
                st.session_state.query_history = []
                st.rerun()

# Footer
st.divider()
st.caption("Nebula Graph Query Tool | Using nGQL Query Language | Data Visualization")
