import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import networkx as nx
from datetime import datetime
import time
import json
import traceback

# Nebula Graph imports
try:
    from nebula3.gclient.net import ConnectionPool
    from nebula3.Config import Config
    from nebula3.data.ResultSet import ResultSet
    from nebula3.data.DataObject import Vertex, Edge, PathWrapper
    NEBULA_AVAILABLE = True
except ImportError:
    NEBULA_AVAILABLE = False
    st.warning("Nebula3 Python client not installed. Please run: pip install nebula3-python")

# Page configuration
st.set_page_config(
    page_title="Nebula Graph Query Tool",
    page_icon="üîÆ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #4B8BBE;
        text-align: center;
        margin-bottom: 2rem;
    }
    .query-box {
        background-color: #f0f2f6;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
    }
    .result-box {
        background-color: #ffffff;
        padding: 15px;
        border-radius: 5px;
        border-left: 4px solid #4B8BBE;
        margin-top: 10px;
    }
    .stButton>button {
        background-color: #4B8BBE;
        color: white;
        font-weight: bold;
    }
    .metric-card {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #dee2e6;
    }
    .space-selector {
        background-color: #e8f4fd;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 15px;
    }
    .vertex-info {
        background-color: #e8f5e8;
        padding: 10px;
        border-radius: 5px;
        margin: 5px 0;
    }
    .edge-info {
        background-color: #e8f0f8;
        padding: 10px;
        border-radius: 5px;
        margin: 5px 0;
    }
</style>
""", unsafe_allow_html=True)

# Application title
st.markdown('<h1 class="main-header">üîÆ Nebula Graph Query & Visualization Tool</h1>', unsafe_allow_html=True)

# Initialize session state
if 'connection_pool' not in st.session_state:
    st.session_state.connection_pool = None
if 'session' not in st.session_state:
    st.session_state.session = None
if 'query_history' not in st.session_state:
    st.session_state.query_history = []
if 'current_space' not in st.session_state:
    st.session_state.current_space = None
if 'available_spaces' not in st.session_state:
    st.session_state.available_spaces = []

def get_value_as_string(value_wrapper):
    """Extract string value from ValueWrapper object - Handle complex types"""
    try:
        # Handle empty and null values
        if value_wrapper.is_empty():
            return ""
        if value_wrapper.is_null():
            return "NULL"
        
        # Handle Vertex type
        if value_wrapper.is_vertex():
            vertex = value_wrapper.get_vertex()
            vid = vertex.get_id()
            
            # Get vertex ID as string
            if hasattr(vid, 'get_sVal'):
                vid_str = vid.get_sVal()
            elif hasattr(vid, 'get_iVal'):
                vid_str = str(vid.get_iVal())
            else:
                vid_str = str(vid)
            
            # Decode if bytes
            if isinstance(vid_str, bytes):
                vid_str = vid_str.decode('utf-8')
            
            # Get tags
            tags = vertex.tags
            tag_info = []
            for tag in tags:
                tag_name = tag.decode('utf-8') if isinstance(tag, bytes) else str(tag)
                tag_info.append(tag_name)
            
            # Get properties
            props = {}
            for tag in tags:
                tag_name = tag.decode('utf-8') if isinstance(tag, bytes) else str(tag)
                tag_props = vertex.properties(tag_name)
                if tag_props:
                    for key, value in tag_props.items():
                        key_str = key.decode('utf-8') if isinstance(key, bytes) else str(key)
                        if hasattr(value, 'get_sVal'):
                            val_str = value.get_sVal()
                        elif hasattr(value, 'get_iVal'):
                            val_str = str(value.get_iVal())
                        else:
                            val_str = str(value)
                        
                        if isinstance(val_str, bytes):
                            val_str = val_str.decode('utf-8')
                        
                        props[f"{tag_name}.{key_str}"] = val_str
            
            return f"Vertex(id={vid_str}, tags={tag_info}, props={props})"
        
        # Handle Edge type
        elif value_wrapper.is_edge():
            edge = value_wrapper.get_edge()
            
            # Get source and destination
            src = edge.src
            dst = edge.dst
            
            if hasattr(src, 'get_sVal'):
                src_str = src.get_sVal()
            elif hasattr(src, 'get_iVal'):
                src_str = str(src.get_iVal())
            else:
                src_str = str(src)
            
            if hasattr(dst, 'get_sVal'):
                dst_str = dst.get_sVal()
            elif hasattr(dst, 'get_iVal'):
                dst_str = str(dst.get_iVal())
            else:
                dst_str = str(dst)
            
            # Decode if bytes
            if isinstance(src_str, bytes):
                src_str = src_str.decode('utf-8')
            if isinstance(dst_str, bytes):
                dst_str = dst_str.decode('utf-8')
            
            # Get edge type
            edge_type = edge.edge_name
            if isinstance(edge_type, bytes):
                edge_type = edge_type.decode('utf-8')
            
            # Get properties
            props = {}
            edge_props = edge.properties
            if edge_props:
                for key, value in edge_props.items():
                    key_str = key.decode('utf-8') if isinstance(key, bytes) else str(key)
                    if hasattr(value, 'get_sVal'):
                        val_str = value.get_sVal()
                    elif hasattr(value, 'get_iVal'):
                        val_str = str(value.get_iVal())
                    else:
                        val_str = str(value)
                    
                    if isinstance(val_str, bytes):
                        val_str = val_str.decode('utf-8')
                    
                    props[key_str] = val_str
            
            return f"Edge(src={src_str}->dst={dst_str}, type={edge_type}, props={props})"
        
        # Handle Path type
        elif value_wrapper.is_path():
            path = value_wrapper.get_path()
            return f"Path(length={len(path.nodes)})"
        
        # Handle basic types
        elif value_wrapper.is_string():
            result = value_wrapper.get_string()
            if isinstance(result, bytes):
                return result.decode('utf-8')
            return result
        
        elif value_wrapper.is_int():
            return str(value_wrapper.get_int())
        
        elif value_wrapper.is_bool():
            return str(value_wrapper.get_bool())
        
        elif value_wrapper.is_double():
            return str(value_wrapper.get_double())
        
        elif value_wrapper.is_list():
            # Handle lists
            list_val = value_wrapper.get_list()
            items = []
            for item in list_val:
                items.append(get_value_as_string(item))
            return f"[{', '.join(items)}]"
        
        elif value_wrapper.is_set():
            # Handle sets
            set_val = value_wrapper.get_set()
            items = []
            for item in set_val:
                items.append(get_value_as_string(item))
            return f"{{{', '.join(items)}}}"
        
        elif value_wrapper.is_map():
            # Handle maps
            map_val = value_wrapper.get_map()
            items = []
            for key, value in map_val.items():
                key_str = get_value_as_string(key)
                val_str = get_value_as_string(value)
                items.append(f"{key_str}: {val_str}")
            return f"{{{', '.join(items)}}}"
        
        else:
            # Fallback to string representation
            result = str(value_wrapper)
            # Clean up byte strings
            if result.startswith("b'") and result.endswith("'"):
                return result[2:-1]
            elif result.startswith('b"') and result.endswith('"'):
                return result[2:-1]
            return result
            
    except Exception as e:
        # Return error information for debugging
        return f"[Error processing value: {str(e)}]"

def initialize_nebula_connection():
    """Initialize Nebula Graph connection"""
    if not NEBULA_AVAILABLE:
        return False
    
    try:
        config = Config()
        config.max_connection_pool_size = 10
        
        connection_pool = ConnectionPool()
        
        # Connection parameters
        addresses = [(st.session_state.get('nebula_host', '127.0.0.1'), 
                     st.session_state.get('nebula_port', 9669))]
        
        # Initialize connection pool
        if not connection_pool.init(addresses, config):
            st.error("Connection pool initialization failed")
            return False
        
        # Get session
        session = connection_pool.get_session(
            st.session_state.get('nebula_username', 'root'),
            st.session_state.get('nebula_password', 'nebula')
        )
        
        # Test connection
        result = session.execute("SHOW HOSTS")
        if not result.is_succeeded():
            st.error(f"Connection test failed: {result.error_msg()}")
            session.release()
            return False
        
        st.session_state.connection_pool = connection_pool
        st.session_state.session = session
        
        # Fetch available spaces
        fetch_available_spaces()
        
        return True
        
    except Exception as e:
        st.error(f"Connection failed: {str(e)}")
        return False

def fetch_available_spaces():
    """Fetch list of available graph spaces"""
    if not st.session_state.session:
        return []
    
    try:
        result = st.session_state.session.execute("SHOW SPACES")
        if result.is_succeeded():
            spaces = []
            
            for record in result:
                try:
                    values = record.values()
                    if values and len(values) > 0:
                        # Get the first column value as space name
                        space_name = get_value_as_string(values[0])
                        
                        # Clean up the space name
                        if space_name and space_name not in ['NULL', 'None', '', 'null']:
                            spaces.append(space_name)
                            
                except Exception:
                    continue
            
            st.session_state.available_spaces = spaces
            return spaces
        else:
            st.error(f"Failed to fetch spaces: {result.error_msg()}")
            return []
    except Exception as e:
        st.error(f"Failed to fetch spaces: {str(e)}")
        return []

def switch_space(space_name):
    """Switch to a specific graph space"""
    if not st.session_state.session:
        st.error("Please connect to Nebula Graph first")
        return False
    
    try:
        # Clean the space name
        space_name = space_name.strip().replace(';', '')
        
        # Execute USE command
        result = st.session_state.session.execute(f"USE {space_name}")
        if result.is_succeeded():
            st.session_state.current_space = space_name
            return True
        else:
            st.error(f"Failed to switch space: {result.error_msg()}")
            return False
    except Exception as e:
        st.error(f"Space switch error: {str(e)}")
        return False

def execute_query(query):
    """Execute query statement"""
    if not st.session_state.session:
        st.error("Please connect to Nebula Graph first")
        return None
    
    # Clean and prepare the query
    query = query.strip()
    if not query:
        st.error("Query cannot be empty")
        return None
    
    # Check if we need to be in a specific space
    requires_space = check_query_requires_space(query)
    
    if requires_space and not st.session_state.current_space:
        st.error("This query requires a graph space to be selected. Please select a space first.")
        return None
    
    try:
        # Execute query
        start_time = time.time()
        result = st.session_state.session.execute(query)
        execution_time = time.time() - start_time
        
        # Record query history
        query_record = {
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'query': query,
            'success': result.is_succeeded(),
            'time': f"{execution_time:.3f}s",
            'space': st.session_state.current_space
        }
        st.session_state.query_history.append(query_record)
        
        # If this is a USE statement, update current space
        if query.strip().upper().startswith("USE "):
            if result.is_succeeded():
                # Extract space name from USE command
                parts = query.split()
                if len(parts) >= 2:
                    space_name = parts[1].replace(';', '')
                    st.session_state.current_space = space_name
                    st.success(f"Switched to space: {space_name}")
                    # Refresh spaces list
                    fetch_available_spaces()
        
        # If this is a CREATE SPACE or DROP SPACE command, refresh spaces
        elif query.strip().upper().startswith(("CREATE SPACE", "DROP SPACE")):
            if result.is_succeeded():
                # Wait a moment for the space to be created/dropped
                time.sleep(1)
                fetch_available_spaces()
        
        return result
        
    except Exception as e:
        st.error(f"Query execution error: {str(e)}")
        return None

def check_query_requires_space(query):
    """Check if a query requires being in a graph space"""
    query_upper = query.strip().upper()
    
    # Queries that don't require a space
    no_space_queries = [
        "SHOW SPACES",
        "CREATE SPACE",
        "DROP SPACE",
        "DESC SPACE",
        "SHOW HOSTS",
        "SHOW SESSIONS",
        "SHOW CONFIGS",
        "SHOW USERS",
        "SHOW ROLES"
    ]
    
    # Check if query starts with any of the no-space queries
    for no_space_query in no_space_queries:
        if query_upper.startswith(no_space_query):
            return False
    
    # Most other queries require a space
    return True

def display_result_table(result):
    """Display result in a table format - Handle complex graph types"""
    if not result or not result.is_succeeded():
        return None
    
    try:
        # Get column names
        columns = result.keys()
        
        # Create data rows
        data = []
        for record in result:
            row = {}
            for i, value_wrapper in enumerate(record.values()):
                col_name = columns[i] if i < len(columns) else f"col_{i}"
                
                # Get the value as string using our improved function
                cell_value = get_value_as_string(value_wrapper)
                
                # Store in row
                row[col_name] = cell_value
            
            data.append(row)
        
        # Display as DataFrame
        if data:
            df = pd.DataFrame(data)
            return df
        else:
            return pd.DataFrame()  # Return empty DataFrame
            
    except Exception as e:
        st.error(f"Error displaying result: {str(e)}")
        st.code(traceback.format_exc())
        return None

def extract_graph_data_from_df(df):
    """Extract graph data (vertices and edges) from DataFrame for visualization"""
    if df is None or df.empty:
        return None, None
    
    try:
        vertices = []
        edges = []
        
        # Look for vertex and edge patterns in the data
        for idx, row in df.iterrows():
            for col in df.columns:
                cell_value = str(row[col])
                
                # Check for vertex pattern
                if cell_value.startswith("Vertex("):
                    try:
                        # Parse vertex information
                        vertex_str = cell_value.split("Vertex(")[1].rstrip(")")
                        # Extract ID
                        if "id=" in vertex_str:
                            id_part = vertex_str.split("id=")[1].split(",")[0]
                            vertices.append(id_part.strip())
                    except:
                        continue
                
                # Check for edge pattern
                elif cell_value.startswith("Edge("):
                    try:
                        # Parse edge information
                        edge_str = cell_value.split("Edge(")[1].rstrip(")")
                        # Extract source and destination
                        if "src=" in edge_str and "dst=" in edge_str:
                            src_part = edge_str.split("src=")[1].split("->")[0]
                            dst_part = edge_str.split("dst=")[1].split(",")[0]
                            edges.append((src_part.strip(), dst_part.strip()))
                    except:
                        continue
        
        return vertices, edges
        
    except Exception as e:
        st.warning(f"Could not extract graph data: {str(e)}")
        return None, None

def visualize_graph_from_data(df):
    """Create graph visualization from DataFrame"""
    if df is None or df.empty:
        return None
    
    try:
        # Extract vertices and edges
        vertices, edges = extract_graph_data_from_df(df)
        
        if not vertices and not edges:
            st.info("No graph data found in results. Try a different query.")
            return None
        
        # Create graph
        G = nx.Graph()
        
        # Add vertices
        if vertices:
            for vertex in vertices:
                G.add_node(vertex)
        
        # Add edges
        if edges:
            for src, dst in edges:
                G.add_edge(src, dst)
        
        # If no edges but vertices, create a simple layout
        if G.number_of_edges() == 0 and G.number_of_nodes() > 0:
            # Create a simple tree structure
            nodes = list(G.nodes())
            for i in range(1, len(nodes)):
                G.add_edge(nodes[i-1], nodes[i])
        
        # Create positions for nodes
        if G.number_of_nodes() > 0:
            pos = nx.spring_layout(G, seed=42, k=1)
        else:
            return None
        
        # Create Plotly figure
        edge_x = []
        edge_y = []
        for edge in G.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_x.extend([x0, x1, None])
            edge_y.extend([y0, y1, None])
        
        edge_trace = go.Scatter(
            x=edge_x, y=edge_y,
            line=dict(width=1, color='#888'),
            hoverinfo='none',
            mode='lines',
            name='Edges'
        )
        
        node_x = []
        node_y = []
        node_text = []
        for node in G.nodes():
            x, y = pos[node]
            node_x.append(x)
            node_y.append(y)
            node_text.append(f"Node: {node}")
        
        node_trace = go.Scatter(
            x=node_x, y=node_y,
            mode='markers+text',
            hoverinfo='text',
            text=list(G.nodes()),
            textposition="bottom center",
            marker=dict(
                showscale=True,
                colorscale='YlGnBu',
                size=20,
                color=[],
                line_width=2
            ),
            name='Nodes'
        )
        
        fig = go.Figure(data=[edge_trace, node_trace],
                       layout=go.Layout(
                           title='Graph Visualization',
                           titlefont_size=16,
                           showlegend=False,
                           hovermode='closest',
                           margin=dict(b=20,l=5,r=5,t=40),
                           xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                           yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
                       ))
        
        return fig
        
    except Exception as e:
        st.warning(f"Could not create graph visualization: {str(e)}")
        return None

# Sidebar - Connection Configuration
with st.sidebar:
    st.header("üîó Connection Configuration")
    
    # Connection parameters
    nebula_host = st.text_input("Nebula Graph Address", value="127.0.0.1", key="nebula_host")
    nebula_port = st.number_input("Port", value=9669, min_value=1, max_value=65535, key="nebula_port")
    nebula_username = st.text_input("Username", value="root", key="nebula_username")
    nebula_password = st.text_input("Password", value="nebula", type="password", key="nebula_password")
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button("Connect to Nebula", use_container_width=True, type="primary"):
            with st.spinner("Connecting..."):
                if initialize_nebula_connection():
                    st.success("Connected successfully!")
    with col2:
        if st.button("Disconnect", use_container_width=True):
            if st.session_state.session:
                st.session_state.session.release()
                st.session_state.connection_pool.close()
                st.session_state.session = None
                st.session_state.connection_pool = None
                st.session_state.current_space = None
                st.session_state.available_spaces = []
                st.info("Disconnected")
    
    st.divider()
    
    # Space Selection
    st.header("üåå Space Management")
    
    if st.session_state.session:
        st.markdown('<div class="space-selector">', unsafe_allow_html=True)
        
        current_space = st.session_state.current_space or "No space selected"
        st.write(f"**Current Space:** `{current_space}`")
        
        # Refresh spaces button
        if st.button("üîÑ Refresh Spaces", use_container_width=True):
            with st.spinner("Fetching spaces..."):
                fetch_available_spaces()
                st.rerun()
        
        # Show available spaces
        if st.session_state.available_spaces:
            # Space selection dropdown
            selected_space = st.selectbox(
                "Select a Graph Space",
                options=[""] + st.session_state.available_spaces,
                index=0,
                help="Select a graph space to work with"
            )
            
            if selected_space:
                if st.button(f"Switch to {selected_space}", use_container_width=True):
                    if switch_space(selected_space):
                        st.success(f"Switched to space: {selected_space}")
                        st.rerun()
            
            st.write(f"**Available spaces ({len(st.session_state.available_spaces)}):**")
            for space in st.session_state.available_spaces:
                if space == st.session_state.current_space:
                    st.markdown(f"‚úÖ `{space}`")
                else:
                    st.markdown(f"`{space}`")
        else:
            st.info("No spaces found. Create a space first.")
            if st.button("Show CREATE SPACE Example", use_container_width=True):
                st.code("CREATE SPACE test_space(vid_type=FIXED_STRING(30))")
        
        st.markdown('</div>', unsafe_allow_html=True)
    else:
        st.info("Connect to see available spaces")
    
    st.divider()
    
    # Query History
    st.header("üìú Query History")
    if st.session_state.query_history:
        for i, record in enumerate(reversed(st.session_state.query_history[-5:])):
            with st.expander(f"{record['timestamp']} - {record['query'][:50]}..."):
                st.code(record['query'])
                status = "‚úÖ Success" if record['success'] else "‚ùå Failed"
                st.caption(f"Status: {status}")
                st.caption(f"Time: {record['time']}")
                if record.get('space'):
                    st.caption(f"Space: {record['space']}")
    else:
        st.caption("No query history yet")
    
    st.divider()
    
    # Query Examples
    st.header("üí° Query Examples")
    examples = {
        "Show all spaces": "SHOW SPACES",
        "Create test space": "CREATE SPACE IF NOT EXISTS test_space(vid_type=FIXED_STRING(30))",
        "Show tags": "SHOW TAGS",
        "Show edge types": "SHOW EDGES",
        "Simple vertex query": "MATCH (v) RETURN v LIMIT 5",
        "Vertex-edge query": "MATCH (v)-[e]->(n) RETURN v, e, n LIMIT 10",
        "Optional match query": "MATCH (v) OPTIONAL MATCH (v)-[e]->(n) RETURN v, e, n LIMIT 5"
    }
    
    selected_example = st.selectbox("Select example query", list(examples.keys()))
    if st.button("Use Example", use_container_width=True):
        st.session_state.example_query = examples[selected_example]

# Main Interface
tab1, tab2, tab3 = st.tabs(["üìù Query Editor", "üìä Data Visualization", "üìà System Status"])

with tab1:
    st.markdown('<div class="query-box">', unsafe_allow_html=True)
    
    # Space warning
    if st.session_state.session and not st.session_state.current_space:
        st.warning("‚ö†Ô∏è No graph space selected. Most queries require a space. Select one from the sidebar or use: `USE your_space_name;`")
    
    # Query input
    query_input = st.text_area(
        "Enter Query Statement",
        height=150,
        value=st.session_state.get('example_query', ''),
        placeholder="Enter your nGQL query, e.g.:\nUSE your_space_name;\nMATCH (v) RETURN v LIMIT 10",
        key="query_input"
    )
    
    col1, col2, col3 = st.columns([1, 1, 2])
    with col1:
        execute_btn = st.button("üöÄ Execute Query", use_container_width=True, type="primary")
    with col2:
        if st.button("üîÑ Clear Results", use_container_width=True):
            if 'last_result_df' in st.session_state:
                del st.session_state.last_result_df
    with col3:
        space_info = st.empty()
        if st.session_state.current_space:
            space_info.success(f"‚úÖ Current space: **{st.session_state.current_space}**")
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Execute query
    if execute_btn and query_input:
        with st.spinner("Executing query..."):
            result = execute_query(query_input)
            
            if result:
                if result.is_succeeded():
                    st.success("Query executed successfully!")
                    
                    # Display result using our table function
                    df = display_result_table(result)
                    
                    if df is not None and not df.empty:
                        # Display statistics
                        st.info(f"Returned {len(df)} rows, {len(df.columns)} columns")
                        
                        # Display data table
                        st.dataframe(df, use_container_width=True)
                        
                        # Save result for visualization
                        st.session_state.last_result_df = df
                        
                        # Show detailed view for complex types
                        with st.expander("üîç Detailed View of Complex Types"):
                            # Check if we have vertex or edge columns
                            vertex_columns = [col for col in df.columns if df[col].astype(str).str.contains('Vertex\(').any()]
                            edge_columns = [col for col in df.columns if df[col].astype(str).str.contains('Edge\(').any()]
                            
                            if vertex_columns:
                                st.markdown("### üìç Vertices Found")
                                for col in vertex_columns:
                                    for idx, value in enumerate(df[col].head(3)):  # Show first 3
                                        if 'Vertex(' in str(value):
                                            st.markdown(f'<div class="vertex-info">**Row {idx}, Column "{col}"**: {value}</div>', unsafe_allow_html=True)
                            
                            if edge_columns:
                                st.markdown("### üîó Edges Found")
                                for col in edge_columns:
                                    for idx, value in enumerate(df[col].head(3)):  # Show first 3
                                        if 'Edge(' in str(value):
                                            st.markdown(f'<div class="edge-info">**Row {idx}, Column "{col}"**: {value}</div>', unsafe_allow_html=True)
                        
                    else:
                        st.info("Query succeeded but no data returned")
                        if hasattr(result, 'comment') and result.comment():
                            st.write(f"Message: {result.comment()}")
                else:
                    error_msg = result.error_msg()
                    st.error(f"Query failed: {error_msg}")
                    
                    # Provide helpful suggestions based on error
                    if "space was not chosen" in error_msg.lower():
                        st.info("üí° **Solution:** You need to select a graph space first. Either:")
                        st.markdown("1. Select a space from the sidebar dropdown")
                        st.markdown("2. Add `USE your_space_name;` at the beginning of your query")
                        st.markdown("3. Create a new space with `CREATE SPACE your_space_name(...)`")

with tab2:
    st.header("Data Visualization")
    
    if 'last_result_df' in st.session_state and st.session_state.last_result_df is not None:
        df = st.session_state.last_result_df
        
        # Visualization type selection
        viz_type = st.radio(
            "Select Visualization Type",
            ["Table View", "Graph View", "Statistics", "JSON View"],
            horizontal=True
        )
        
        if viz_type == "Table View":
            # Interactive data table
            edited_df = st.data_editor(df, use_container_width=True)
            
            # Data export options
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("Export as CSV"):
                    csv = df.to_csv(index=False).encode('utf-8')
                    st.download_button(
                        label="Download CSV",
                        data=csv,
                        file_name=f"nebula_result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        mime="text/csv"
                    )
        
        elif viz_type == "Graph View":
            fig = visualize_graph_from_data(df)
            if fig:
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("No graph data found in results. Showing table view instead:")
                st.dataframe(df, use_container_width=True)
            
        elif viz_type == "Statistics":
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("Data Overview")
                st.markdown('<div class="metric-card">', unsafe_allow_html=True)
                st.metric("Total Rows", len(df))
                st.metric("Total Columns", len(df.columns))
                st.markdown('</div>', unsafe_allow_html=True)
                
                # Data type statistics
                st.subheader("Column Types")
                type_info = []
                for col in df.columns:
                    # Check if column contains graph types
                    if df[col].astype(str).str.contains('Vertex\(').any():
                        col_type = "Vertex"
                    elif df[col].astype(str).str.contains('Edge\(').any():
                        col_type = "Edge"
                    elif df[col].astype(str).str.contains('Path\(').any():
                        col_type = "Path"
                    else:
                        col_type = str(df[col].dtype)
                    
                    non_null = df[col].notnull().sum()
                    unique_count = df[col].nunique()
                    type_info.append({
                        'Column': col,
                        'Type': col_type,
                        'Non-Null': non_null,
                        'Unique': unique_count
                    })
                
                if type_info:
                    st.dataframe(pd.DataFrame(type_info), use_container_width=True)
            
            with col2:
                st.subheader("Graph Data Analysis")
                # Count vertices and edges
                vertex_count = 0
                edge_count = 0
                
                for col in df.columns:
                    if df[col].astype(str).str.contains('Vertex\(').any():
                        vertex_count += df[col].notnull().sum()
                    if df[col].astype(str).str.contains('Edge\(').any():
                        edge_count += df[col].notnull().sum()
                
                st.markdown('<div class="metric-card">', unsafe_allow_html=True)
                st.metric("Vertices Found", vertex_count)
                st.metric("Edges Found", edge_count)
                st.markdown('</div>', unsafe_allow_html=True)
        
        elif viz_type == "JSON View":
            # Show data as JSON
            json_data = df.to_dict(orient='records')
            st.json(json_data)
    
    else:
        st.info("Please execute a query in the Query Editor tab first")

with tab3:
    st.header("System Status")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Connection Status")
        status_card = st.container()
        with status_card:
            if st.session_state.session:
                st.success("‚úÖ Connected")
                st.metric("Current Space", st.session_state.current_space or "Not selected")
                if st.session_state.current_space:
                    st.markdown(f"Space selected: `{st.session_state.current_space}`")
            else:
                st.error("‚ùå Not connected")
        
        st.subheader("Query Statistics")
        if st.session_state.query_history:
            total_queries = len(st.session_state.query_history)
            successful_queries = sum(1 for q in st.session_state.query_history if q['success'])
            success_rate = (successful_queries / total_queries * 100) if total_queries > 0 else 0
            
            st.markdown('<div class="metric-card">', unsafe_allow_html=True)
            st.metric("Total Queries", total_queries)
            st.metric("Success Rate", f"{success_rate:.1f}%")
            st.markdown('</div>', unsafe_allow_html=True)
    
    with col2:
        st.subheader("System Information")
        st.markdown('<div class="metric-card">', unsafe_allow_html=True)
        st.write(f"Current Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        st.write(f"Streamlit Version: {st.__version__}")
        st.write(f"Nebula Client Available: {NEBULA_AVAILABLE}")
        st.write(f"Available Spaces: {len(st.session_state.available_spaces)}")
        
        # Handle bytes in spaces list
        if st.session_state.available_spaces:
            space_strings = []
            for space in st.session_state.available_spaces:
                if isinstance(space, bytes):
                    try:
                        space_strings.append(space.decode('utf-8'))
                    except:
                        space_strings.append(str(space))
                else:
                    space_strings.append(str(space))
            
            st.write("Spaces:", ", ".join(space_strings))
        
        st.markdown('</div>', unsafe_allow_html=True)
        
        # Quick actions
        st.subheader("Quick Actions")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("Refresh Spaces", use_container_width=True):
                if st.session_state.session:
                    fetch_available_spaces()
                    st.rerun()
                else:
                    st.error("Not connected")
        
        with col2:
            if st.button("Clear History", use_container_width=True):
                st.session_state.query_history = []
                st.rerun()

# Footer
st.divider()
st.caption("Nebula Graph Query Tool | Using nGQL Query Language | Data Visualization")

# Troubleshooting guide
with st.expander("üîß Graph Query Troubleshooting Guide"):
    st.markdown("""
    ### Understanding Graph Query Results
    
    When you run queries like `MATCH (v) OPTIONAL MATCH (v)-[e]->(n) RETURN v, e, n`, you get:
    
    1. **v (Vertex)**: Graph vertex object with ID, tags, and properties
    2. **e (Edge)**: Graph edge object with source, destination, type, and properties  
    3. **n (Vertex)**: Neighbor vertex object (or NULL if no edge exists)
    
    ### Why "Error" Appears
    
    In previous versions, the display function couldn't handle complex graph types. Now:
    
    - ‚úÖ **Vertices** show as: `Vertex(id=..., tags=[...], props={...})`
    - ‚úÖ **Edges** show as: `Edge(src=...->dst=..., type=..., props={...})`
    - ‚úÖ **NULL values** show as: `NULL`
    
    ### Tips for Better Queries
    
    ```sql
    -- 1. Limit results for testing
    MATCH (v) OPTIONAL MATCH (v)-[e]->(n) RETURN v, e, n LIMIT 10
    
    -- 2. Return specific properties
    MATCH (v:player) RETURN v.player.name, v.player.age LIMIT 10
    
    -- 3. Use WHERE clause
    MATCH (v:player)-[e:follows]->(n) 
    WHERE v.player.age > 30 
    RETURN v, e, n LIMIT 10
    ```
    
    ### Common Issues
    
    1. **No data returned**: Make sure you've created vertices and edges
    2. **NULL values**: OPTIONAL MATCH may return NULL if no matches
    3. **Memory issues**: LIMIT large queries (like 3000 rows)
    """)

# Add a simpler query helper
with st.expander("üìã Simple Query Templates"):
    template = st.selectbox(
        "Choose a query template",
        [
            "Basic vertex query",
            "Basic edge query", 
            "Vertex with properties",
            "Path query",
            "Aggregation query"
        ]
    )
    
    templates = {
        "Basic vertex query": "MATCH (v) RETURN v LIMIT 10",
        "Basic edge query": "MATCH ()-[e]->() RETURN e LIMIT 10",
        "Vertex with properties": "MATCH (v:player) RETURN v.player.name AS name, v.player.age AS age LIMIT 10",
        "Path query": "MATCH p=(v1)-[e*2]-(v2) RETURN p LIMIT 5",
        "Aggregation query": "MATCH (v:player) RETURN COUNT(v) AS player_count"
    }
    
    if template in templates:
        st.code(templates[template], language="sql")
        if st.button(f"Use {template} Template", use_container_width=True):
            st.session_state.example_query = templates[template]
            st.rerun()
