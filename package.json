import os
import json
from pathlib import Path
import PyPDF2
import zipfile
import py7zr
import base64
import logging
import requests
from fpdf import FPDF
from docx2pdf import convert
import pandas as pd
from docling.document_converter import DocumentConverter
import img2pdf
import win32com.client
import pythoncom
import urllib3
import tempfile
import shutil
from src.contract_extractor.utils.json_utils import coerce_to_json

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class ContractMetadataExtractor:
    def __init__(self, base_folder, prompt_template_path, llm_callback, output_folder):
        self.base_folder = base_folder
        self.llm_callback = llm_callback
        self.output_folder = output_folder

        with open(prompt_template_path, 'r', encoding='utf-8') as f:
            self.prompt_template = f.read()
    
    def extract_text_from_pdf(self, pdf_path):
        try:
            with open(pdf_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                text = ""
                for page in pdf_reader.pages:
                    text += page.extract_text() + "\n"
                return text
        except Exception as e:
            logger.error(f"Fail to extract file: {pdf_path}, error: {e}")
            return None
    
    def get_pdf_page_count(self, pdf_path):
        """Get the page count of PDF"""
        try:
            with open(pdf_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                return len(pdf_reader.pages)
        except Exception as e:
            logger.error(f"Failed to get page count for {pdf_path}: {e}")
            return 0
    
    def convert_pdf_to_markdown(self, pdf_path):
        try:
            converter = DocumentConverter()
            result = converter.convert(pdf_path)
            return result.document.text
        except ImportError:
            logger.error("Docling not installed. Please install it with: pip install docling")
            return None
        except Exception as e:
            logger.error(f"Failed to convert PDF to markdown: {e}")
            return None
        
    def file_to_base64(self, file_path):
        try:
            with open(file_path, "rb") as file:
                encoded_content = base64.b64encode(file.read()).decode('utf-8')
            return encoded_content
        except Exception as e:
            print(f"Error converting file {file_path} to Base64: {e}")
            return None
    
    def convert_xlsx_to_pdf(self, xlsx_path, pdf_path):
        """convert Excel to PDF"""
        try:
            df = pd.read_excel(xlsx_path, sheet_name=None)
            html_content = "<html><head><style>table {border-collapse: collapse; width: 100%;} th, td {border: 1px solid black; padding: 8px; text-align: left;}</style></head><body>"
            
            for sheet_name, data in df.items():
                html_content += f"<h2>Sheet: {sheet_name}</h2>"
                html_content += data.to_html(index=False, classes='table table-striped')
                html_content += "<br>"
            
            html_content += "</body></html>"
            return self._convert_xlsx_to_pdf_fallback(xlsx_path, pdf_path)
        except Exception as e:
            logger.error(f"Failed to convert Excel to PDF: {e}")
            return False
    
    def _convert_xlsx_to_pdf_fallback(self, xlsx_path, pdf_path):
        try:
            df = pd.read_excel(xlsx_path)
            csv_temp_path = pdf_path.replace('.pdf', '.csv')
            df.to_csv(csv_temp_path, index=False)
            return self.convert_csv_to_pdf(csv_temp_path, pdf_path)
        except Exception as e:
            logger.error(f"Fallback conversion failed: {e}")
            return False
    
    def convert_csv_to_pdf(self, csv_path, pdf_path):
        """convert CSV to PDF"""
        try:
            df = pd.read_csv(csv_path)
            
            # 创建支持中文的PDF
            pdf = FPDF()
            pdf.add_page()
            
            # 添加支持中文的字体
            try:
                # 尝试使用系统中文字体
                pdf.add_font('SimSun', '', 'C:/Windows/Fonts/simsun.ttc', uni=True)
                pdf.set_font('SimSun', size=10)
            except:
                try:
                    # 尝试其他中文字体
                    pdf.add_font('DejaVu', '', 'DejaVuSans.ttf', uni=True)
                    pdf.set_font('DejaVu', size=10)
                except:
                    # 回退到默认字体
                    pdf.set_font("Arial", size=10)
            
            pdf.cell(200, 10, txt=f"CSV File: {Path(csv_path).name}", ln=True, align='C')
            pdf.ln(10)
            
            # 处理数据，确保字符串编码正确
            for index, row in df.iterrows():
                try:
                    line = " | ".join([str(x) for x in row.values])
                    # 确保文本正确编码
                    if isinstance(line, str):
                        line = line.encode('latin-1', 'replace').decode('latin-1')
                    pdf.multi_cell(0, 10, txt=line)
                except Exception as e:
                    logger.warning(f"Error processing row {index}: {e}")
                    continue
                
                if index > 50:
                    pdf.cell(0, 10, txt="... (truncated)", ln=True)
                    break
            
            pdf.output(pdf_path)
            return True
        except Exception as e:
            logger.error(f"Failed to convert CSV to PDF: {e}")
            return False
    
    def convert_image_to_pdf(self, image_path, pdf_path):
        """convert image to PDF"""
        try:
            with open(pdf_path, "wb") as f:
                f.write(img2pdf.convert(image_path))
            return True
        except Exception as e:
            logger.error(f"Failed to convert image to PDF: {e}")
            return False

    def extract_msg_attachments(self, msg_path, extract_to):
        """Extract attachments from Outlook email"""
        attachments_info = []
        try:
            pythoncom.CoInitialize()
            outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
            msg = outlook.OpenSharedItem(msg_path)
            
            # Create directory for attachments
            os.makedirs(extract_to, exist_ok=True)
            
            # Extract all attachments
            for attachment in msg.Attachments:
                try:
                    attachment_path = os.path.join(extract_to, attachment.FileName)
                    attachment.SaveAsFile(attachment_path)
                    attachments_info.append({
                        'filename': attachment.FileName,
                        'path': attachment_path,
                        'size': os.path.getsize(attachment_path)
                    })
                    logger.info(f"Extracted attachment: {attachment.FileName}")
                except Exception as e:
                    logger.error(f"Failed to extract attachment {attachment.FileName}: {e}")
            
            return attachments_info
            
        except Exception as e:
            logger.error(f"Failed to extract attachments from MSG: {e}")
            return []
        finally:
            pythoncom.CoUninitialize()

    def safe_text_for_pdf(self, text):
        """确保文本可以安全地写入PDF"""
        if text is None:
            return ""
        try:
            # 尝试编码为latin-1，替换无法编码的字符
            return text.encode('latin-1', 'replace').decode('latin-1')
        except:
            # 如果仍然失败，返回ASCII安全版本
            return text.encode('ascii', 'ignore').decode('ascii')

    def convert_msg_to_pdf(self, msg_path, pdf_path):
        """Convert Outlook emails to PDF with attachment information"""
        try:
            pythoncom.CoInitialize()
            outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
            msg = outlook.OpenSharedItem(msg_path)
            
            # Create temporary directory for attachments
            temp_dir = tempfile.mkdtemp()
            attachments_info = self.extract_msg_attachments(msg_path, temp_dir)
            
            # Build email content with attachment info
            content = f"""
            Subject: {self.safe_text_for_pdf(msg.Subject)}
            From: {self.safe_text_for_pdf(msg.SenderName)} ({self.safe_text_for_pdf(msg.SenderEmailAddress)})
            To: {self.safe_text_for_pdf(msg.To)}
            CC: {self.safe_text_for_pdf(getattr(msg, 'CC', 'N/A'))}
            Date: {msg.SentOn}
            
            Body:
            {self.safe_text_for_pdf(msg.Body)}
            
            Attachments ({len(attachments_info)}):
            """
            
            # Add attachment list
            for i, att_info in enumerate(attachments_info, 1):
                content += f"\n{i}. {self.safe_text_for_pdf(att_info['filename'])} ({att_info['size']} bytes)"
            
            # 创建PDF并处理编码问题
            pdf = FPDF()
            pdf.add_page()
            
            # 设置支持中文的字体
            try:
                # 尝试使用系统中文字体
                pdf.add_font('SimSun', '', 'C:/Windows/Fonts/simsun.ttc', uni=True)
                pdf.set_font('SimSun', size=10)
            except:
                try:
                    # 尝试其他中文字体
                    pdf.add_font('DejaVu', '', 'DejaVuSans.ttf', uni=True)
                    pdf.set_font('DejaVu', size=10)
                except:
                    # 回退到默认字体
                    pdf.set_font("Arial", size=10)
            
            # 安全写入文本
            safe_content = self.safe_text_for_pdf(content)
            pdf.multi_cell(0, 8, txt=safe_content)
            pdf.output(pdf_path)
            
            # Clean up temporary directory
            shutil.rmtree(temp_dir, ignore_errors=True)
            
            return True, attachments_info
            
        except Exception as e:
            logger.error(f"Failed to convert MSG to PDF: {e}")
            # Clean up on error
            if 'temp_dir' in locals():
                shutil.rmtree(temp_dir, ignore_errors=True)
            return False, []
        finally:
            pythoncom.CoUninitialize()

    def process_msg_with_attachments(self, msg_path, contract_name, file_name):
        """Process MSG file and its attachments"""
        msg_results = {}
        
        # Create temp directory for MSG processing
        temp_msg_dir = os.path.join("temp_conversions", contract_name, Path(file_name).stem)
        os.makedirs(temp_msg_dir, exist_ok=True)
        
        temp_pdf_path = os.path.join(temp_msg_dir, Path(file_name).stem + '.pdf')
        attachments_dir = os.path.join(temp_msg_dir, "attachments")
        
        # Convert MSG to PDF and extract attachments
        conversion_success, attachments_info = self.convert_msg_to_pdf(msg_path, temp_pdf_path)
        
        if not conversion_success:
            msg_results[file_name] = "Failed to convert MSG to PDF"
            return msg_results
        
        # Process the main email PDF
        try:
            email_result = self._process_pdf_file(temp_pdf_path, contract_name, f"{Path(file_name).stem}_email")
            msg_results["email_body"] = email_result
        except Exception as e:
            logger.error(f"Failed to process email body: {e}")
            msg_results["email_body"] = f"Failed: {str(e)}"
        
        # Process each attachment
        msg_results["attachments"] = {}
        for att_info in attachments_info:
            try:
                attachment_file_name = Path(att_info['path']).name
                logger.info(f"Processing attachment: {attachment_file_name}")
                
                # Process the attachment file
                attachment_result = self.process_single_file(att_info['path'], contract_name)
                msg_results["attachments"][attachment_file_name] = attachment_result
                
            except Exception as e:
                logger.error(f"Failed to process attachment {att_info['filename']}: {e}")
                msg_results["attachments"][att_info['filename']] = f"Failed: {str(e)}"
        
        # Clean up temporary files
        try:
            if os.path.exists(temp_pdf_path):
                os.remove(temp_pdf_path)
            if os.path.exists(attachments_dir):
                shutil.rmtree(attachments_dir, ignore_errors=True)
        except Exception as e:
            logger.warning(f"Failed to clean up temporary files: {e}")
        
        return msg_results

    def _process_pdf_file(self, pdf_path, contract_name, file_base_name):
        """Process PDF file and return result"""
        try:
            page_count = self.get_pdf_page_count(pdf_path)
            logger.info(f"PDF page count: {page_count}")
            
            if page_count > 80:
                logger.info(f"Document has {page_count} pages, converting to markdown...")
                markdown_content = self.convert_pdf_to_markdown(pdf_path)
                if markdown_content:
                    prompt = self.build_prompt_with_markdown(contract_name, markdown_content, self.prompt_template)
                else:
                    logger.warning("Docling conversion failed, falling back to text extraction")
                    text_content = self.extract_text_from_pdf(pdf_path)
                    prompt = self.build_prompt_with_text(contract_name, text_content, self.prompt_template)
            else:
                encoded_content = self.file_to_base64(pdf_path)
                prompt = self.build_prompt_with_pdf(contract_name, encoded_content, self.prompt_template)
            
            llm_result = self.llm_callback(prompt)
            output_result = coerce_to_json(llm_result)
            
            # Save results
            output_filename = file_base_name + '.json'
            output_folder = os.path.join(self.output_folder, contract_name)
            os.makedirs(output_folder, exist_ok=True)
            output_path = os.path.join(output_folder, output_filename)
            
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(output_result, f, ensure_ascii=False, indent=2)
            
            logger.info(f"Saved results: {output_path}")
            return "Successfully processed"
            
        except Exception as e:
            logger.error(f"Process failed for PDF: {e}")
            return f"Failed: {str(e)}"

    def extract_files_from_archive(self, archive_path, extract_to):
        """Extract files from archive and return list of extracted file paths"""
        extracted_files = []
        try:
            if archive_path.endswith('.zip'):
                with zipfile.ZipFile(archive_path, 'r') as zip_ref:
                    zip_ref.extractall(extract_to)
                    extracted_files = [os.path.join(extract_to, f) for f in zip_ref.namelist()]
            elif archive_path.endswith('.7z'):
                with py7zr.SevenZipFile(archive_path, mode='r') as z:
                    z.extractall(path=extract_to)
                    extracted_files = [os.path.join(extract_to, f) for f in z.getnames()]
            logger.info(f"Extracted {len(extracted_files)} files from {archive_path}")
            return extracted_files
        except Exception as e:
            logger.error(f"Error extracting {archive_path}: {e}")
            return []

    def process_archive_files(self, archive_path, contract_name, file_name):
        """Process archive files and return results"""
        archive_results = {}
        extracted_folder = os.path.join("temp_extracted", contract_name, Path(file_name).stem)
        os.makedirs(extracted_folder, exist_ok=True)
        
        extracted_files = self.extract_files_from_archive(archive_path, extracted_folder)
        if not extracted_files:
            archive_results[file_name] = "Failed to extract archive or archive is empty"
            return archive_results
        
        for extracted_file in extracted_files:
            if os.path.isfile(extracted_file):
                extracted_file_name = Path(extracted_file).name
                logger.info(f"Processing extracted file: {extracted_file_name}")
                file_result = self.process_single_file(extracted_file, contract_name)
                archive_results[extracted_file_name] = file_result
        
        return archive_results

    def process_single_file(self, file_path, contract_name):
        """Process a single file and return result"""
        file_name = Path(file_path).name
        file_extension = Path(file_path).suffix.lower()
        
        output_filename = Path(file_name).stem + '.json'
        output_folder = os.path.join(self.output_folder, contract_name)
        os.makedirs(output_folder, exist_ok=True)
        output_path = os.path.join(output_folder, output_filename)

        if os.path.exists(output_path):
            logger.info(f"File processed already: {output_path}")
            return "Processed Already!"

        logger.info(f"Processing file: {file_name}")

        # Handle MSG files with attachments
        if file_extension == '.msg':
            return self.process_msg_with_attachments(file_path, contract_name, file_name)

        # For other file types, proceed with original conversion logic
        os.makedirs("temp_conversions", exist_ok=True)
        temp_pdf_path = os.path.join("temp_conversions", Path(file_name).stem + '.pdf')
        
        conversion_success = False
        
        if file_extension == '.pdf':
            temp_pdf_path = file_path
            conversion_success = True
            
        elif file_extension == '.docx':
            try:
                convert(file_path, temp_pdf_path)
                conversion_success = True
            except Exception as e:
                logger.error(f"Failed to convert DOCX to PDF: {e}")
                
        elif file_extension in ['.xlsx', '.xls']:
            conversion_success = self.convert_xlsx_to_pdf(file_path, temp_pdf_path)
            
        elif file_extension == '.csv':
            conversion_success = self.convert_csv_to_pdf(file_path, temp_pdf_path)
            
        elif file_extension in ['.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.tif']:
            conversion_success = self.convert_image_to_pdf(file_path, temp_pdf_path)
            
        elif file_extension in ['.7z', '.zip']:
            archive_results = self.process_archive_files(file_path, contract_name, file_name)
            return archive_results

        else:
            logger.warning(f"Unsupported file format: {file_name}")
            return f"Unsupported format: {file_extension}"

        if not conversion_success:
            logger.error(f"Failed to convert {file_name} to PDF")
            return "Conversion to PDF failed"

        # Process the converted PDF
        try:
            result = self._process_pdf_file(temp_pdf_path, contract_name, Path(file_name).stem)
            
            # Clean up temporary PDF file if it was created
            if file_extension != '.pdf' and os.path.exists(temp_pdf_path) and temp_pdf_path != file_path:
                try:
                    os.remove(temp_pdf_path)
                except Exception as e:
                    logger.warning(f"Failed to remove temporary file {temp_pdf_path}: {e}")
            
            return result
            
        except Exception as e:
            logger.error(f"Process failed for {file_name}: {e}")
            # Clean up on error
            if file_extension != '.pdf' and os.path.exists(temp_pdf_path) and temp_pdf_path != file_path:
                try:
                    os.remove(temp_pdf_path)
                except Exception as e:
                    logger.warning(f"Failed to remove temporary file {temp_pdf_path}: {e}")
            return f"Failed: {str(e)}"
    
    def process_single_contract(self, contract_folder):
        contract_name = Path(contract_folder).name
        logger.info(f"Processing contract: {contract_name}")

        contract_files = [f for f in os.listdir(contract_folder) if os.path.isfile(os.path.join(contract_folder, f))]
        
        if not contract_files:
            logger.warning(f"No files in the folder: {contract_folder}")
            return {}
        
        results = {}
        
        for contract_file in contract_files:
            file_path = os.path.join(contract_folder, contract_file)
            file_result = self.process_single_file(file_path, contract_name)
            results[contract_file] = file_result
        
        return results
    
    def process_all_contracts(self):
        all_results = {}

        subfolders = [f.path for f in os.scandir(self.base_folder) if f.is_dir()]
        
        if not subfolders:
            logger.warning(f"No sub folders in: {self.base_folder}")
            return all_results
        
        for folder in subfolders:
            try:
                results = self.process_single_contract(folder)
                if results:
                    all_results[Path(folder).name] = results
            except Exception as e:
                logger.error(f"Folder process failed: {folder}: {e}")
                all_results[Path(folder).name] = f"Failed: {str(e)}"
        
        return all_results
    
    def build_prompt_with_pdf(self, contract_number, pdf_base64, base_prompt):
        """Build prompt that include the PDF file"""
        prompt_replace = base_prompt.replace("{{contract_number}}", contract_number)
        prompt = [{
            "type": "text",
            "text": prompt_replace
        },
        {
            "type": "document",
            "source": {
                "type": "base64",
                "media_type": "application/pdf",
                "data": pdf_base64
            }
        }]
        return prompt
    
    def build_prompt_with_markdown(self, contract_number, markdown_content, base_prompt):
        """Build prompt that include the markdown content"""
        prompt_replace = base_prompt.replace("{{contract_number}}", contract_number)
        full_prompt = f"{prompt_replace}\n\nDocument Content (Markdown format):\n{markdown_content}"
        
        prompt = [{
            "type": "text",
            "text": full_prompt
        }]
        return prompt
    
    def build_prompt_with_text(self, contract_number, text_content, base_prompt):
        """Build prompt based on the text content only"""
        prompt_replace = base_prompt.replace("{{contract_number}}", contract_number)
        full_prompt = f"{prompt_replace}\n\nDocument Content:\n{text_content}"
        
        prompt = [{
            "type": "text",
            "text": full_prompt
        }]
        return prompt

def llm_callback(prompt):
    # Your existing LLM callback implementation
    def get_token():
        token_response = requests.get('', verify=False)
        token = token_response.json().get('access_token')
        return token

    TOKEN = get_token()

    headers = {'Authorization': f"Bearer {TOKEN}", 'Content-Type': 'application/json'}
    payload = {
        "model":"claude-sonnet-4-5",
        "messages":[
            {
            "role": "system",
            "content": [
                {
                    "type": "text",
                    "text": "\nYou are an expert in document processing and meta data extraction"
                }
            ]
        },
            {
                "role": "user",
                "content": prompt
            }  
        ],
        "temperature": 0.0,
        "seed": 42
    }
    llm_response = requests.post('', json=payload, headers=headers, verify=False)

    if llm_response.status_code == 200:
        llm_output = llm_response.json().get('choices')[0]['message']['content']
        return llm_output
    else:
        logger.error(f"Error in LLM response: {llm_response.status_code} - {llm_response.text}")
        return None

if __name__ == "__main__":
    BASE_FOLDER = r"C:\Users\1657820\Documents\datasets\contract_extractor\Li"
    PROMPT_TEMPLATE_PATH = r"config\config.txt"
    
    extractor = ContractMetadataExtractor(
        base_folder=BASE_FOLDER,
        prompt_template_path=PROMPT_TEMPLATE_PATH,
        llm_callback=llm_callback,
        output_folder= "fil_out")
    
    results = extractor.process_all_contracts()

    report_path = os.path.join(BASE_FOLDER, "processing_report.json")
    with open(report_path, 'w', encoding='utf-8') as f:
        json.dump(results, f, ensure_ascii=False, indent=2)
    
    logger.info(f"Process completed! Saved in: {report_path}")
